[{"title":"Git 基础操作","url":"/2023/12/06/Git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","content":"1 初始化本地 Git 仓库git init\n2 把所有文件都加入到暂存区git add .\n3 本地提交更新git commit -m &quot;init project&quot;\n4 查看分支git branch\n5 创建 test 分支git checkout -b test\n6 将本地的 test 分支进行本地的 commit 提交git add .git commit -m &quot;完成了 test 的开发&quot;\n7 将本地的 test 分支推送到远程仓库进行保存git push -u origin test\n8 将本地的 test 分支合并到本地的 main 分支git checkout mastergit merge tabbar\n9 删除本地的 test 分支git branch -d test\n10 将本地的 main 分支推送到远程仓库进行保存git push","categories":["Git","Git 基础"],"tags":["Git","笔记"]},{"title":"使用 Vant 组件库实现底部导航 Tabbar","url":"/2023/12/08/Vue2-Vant%E7%BB%84%E4%BB%B6%E5%BA%93-%E4%BD%BF%E7%94%A8vant%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AAtabbar/","content":"1 vant-ui,js 按需引入官方地址：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/tabbar\nicon图标：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/icon\nimport Vue from &#x27;vue&#x27;;import &#123; Tabbar, TabbarItem &#125; from &#x27;vant&#x27;;Vue.use(Tabbar)Vue.use(TabbarItem)\n2 组件中使用&lt;van-tabbar v-model=&quot;active&quot; active-color=&quot;#ee0a24&quot; inactive-color=&quot;#000&quot;&gt;  &lt;van-tabbar-item icon=&quot;home-o&quot;&gt;标签&lt;/van-tabbar-item&gt;  &lt;van-tabbar-item icon=&quot;search&quot;&gt;标签&lt;/van-tabbar-item&gt;  &lt;van-tabbar-item icon=&quot;friends-o&quot;&gt;标签&lt;/van-tabbar-item&gt;  &lt;van-tabbar-item icon=&quot;setting-o&quot;&gt;标签&lt;/van-tabbar-item&gt;&lt;/van-tabbar&gt;\n&lt;!-- 路由模式 --&gt;&lt;router-view /&gt;&lt;van-tabbar route&gt;  &lt;van-tabbar-item replace to=&quot;/home&quot; icon=&quot;home-o&quot;&gt;标签&lt;/van-tabbar-item&gt;  &lt;van-tabbar-item replace to=&quot;/search&quot; icon=&quot;search&quot;&gt;标签&lt;/van-tabbar-item&gt;&lt;/van-tabbar&gt;","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Tabbar","Vant 组件库"]},{"title":"使用 Vant 组件库实现顶部导航栏 Navbar","url":"/2023/12/08/Vue2-Vant%E7%BB%84%E4%BB%B6%E5%BA%93-%E4%BD%BF%E7%94%A8vant%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AE%9E%E7%8E%B0%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8Fnavbar/","content":"1 vant-ui,js 按需引入官方地址：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/nav-bar\nimport Vue from &#x27;vue&#x27;;import &#123; NavBar &#125; from &#x27;vant&#x27;;Vue.use(NavBar);\n2 组件中使用&lt;van-nav-bar  title=&quot;标题&quot;  left-text=&quot;返回&quot;  right-text=&quot;按钮&quot;  left-arrow  @click-left=&quot;$router.go(-1)&quot;  @click-right=&quot;onClickRight&quot;/&gt;\n3 修改样式// 设置导航条 返回箭头 颜色.van-nav-bar &#123;  .van-icon-arrow-left &#123;    color: #333;  &#125;&#125;","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库","Navbar"]},{"title":"基于 postcss 插件实现项目 vw 配置","url":"/2023/12/07/Vue2-Vant%E7%BB%84%E4%BB%B6%E5%BA%93-%E5%9F%BA%E4%BA%8Epostcss%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AEvw%E9%85%8D%E7%BD%AE/","content":"1 安装1.1 postcss官方地址&emsp;&emsp;https://vant-contrib.gitee.io/vant/v2/#/zh-CN/advanced-usage#liu-lan-qi-gua-pei\n1.2 通过 npm 安装npm i postcss-px-to-viewport@1.1.1 -D\n2 引入组件// 新建postcss.config.jsmodule.exports = &#123;  plugins: &#123;    &#x27;postcss-px-to-viewport&#x27;: &#123;      // vw适配的标准屏的宽度，iphoneX      viewportWidth: 375    &#125;  &#125;&#125;\n// 组件中，直接按照px写就可以适配不同屏幕&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot;&gt;  .box &#123;    width: 200px;    height: 300px;    background-color: pink;  &#125;&lt;/style&gt;","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库","postcss"]},{"title":"使用定时器倒计时","url":"/2023/12/10/Vue2-Vue2%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%80%92%E8%AE%A1%E6%97%B6/","content":"&lt;button @click=&quot;getCode&quot;&gt;  &#123;&#123;    second === totalSecond ? &#x27;获取验证码&#x27; : second + &#x27;秒后重新发送&#x27;  &#125;&#125;&lt;/button&gt;&lt;script&gt;export default &#123;  name: &#x27;LoginPage&#x27;,  data() &#123;    return &#123;      totalSecond: 60, // 总秒数      second: 60, // 当前秒数，开定时器对 second--      timer: null // 定时器 id    &#125;  &#125;,  // 离开页面清除定时器  destroyed() &#123;    clearInterval(this.timer)  &#125;,  methods: &#123;    // 获取短信验证码    getCode() &#123;      // 开启倒计时      if (this.timer || this.second !=== this.totalSecond) return      this.timer = setInterval(() =&gt; &#123;        this.second--        if (this.second &lt;= 0) &#123;          clearInterval(this.timer)          this.timer = null // 重置定时器 id          this.second = this.totalSecond // 归位        &#125;      &#125;, 1000)    &#125;  &#125;&#125;&lt;/script&gt;\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2","定时器"]},{"title":"全局前置导航守卫","url":"/2023/12/12/Vue2-Vue2%E5%9F%BA%E7%A1%80-%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/","content":"1 配置 vue-router参考方法：Vue2 中 router/index.js 基础配置\n2 配置全局导航守卫官网：https://router.vuejs.org/zh/guide/advanced/navigation-guards.html\nconst router = new VueRouter(&#123;......&#125;)router.beforeEach((to, from, next) =&gt; &#123;  // 1. to   往哪里去， 到哪去的路由信息对象  //    to.path 跳转路径  //    to.fullPath 包含查询参数的跳转路径  // 2. from 从哪里来， 从哪来的路由信息对象  // 3. next() 是否放行  //    如果next()调用，就是放行  //    next(路径) 拦截到某个路径页面&#125;)export default router\nimport store from &#x27;@/store&#x27;.....const authUrl = [&#x27;/pay&#x27;, &#x27;/myorder&#x27;]router.beforeEach((to, from, next) =&gt; &#123;  const token = store.state.user.userInfo.token  if (!authUrl.includes(to.path)) &#123;    next()    return  &#125;  // 跳转权限页，判断有无token  if (token) &#123;    next()  &#125; else &#123;    next(&#x27;/login&#x27;)  &#125;&#125;)","categories":["Vue2","Vue2 基础"],"tags":["Vue2","vue-router"]},{"title":"响应拦截器统一处理错误","url":"/2023/12/12/Vue2-Vue2%E5%9F%BA%E7%A1%80-%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/","content":"1 配置 Axios参考方法：Axios 封装\n2 配置响应拦截器import &#123; Toast &#125; from &#x27;vant&#x27;...// 添加响应拦截器request.interceptors.response.use(function (response) &#123;  const res = response.data  if (res.status !== 200) &#123;    // 给提示    Toast(res.message)    // 抛出一个错误的Promise    return Promise.reject(res.message)  &#125;  // 对响应数据做点什么  return res&#125;, function (error) &#123;  // 对响应错误做点什么  return Promise.reject(error)&#125;)\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Axios"]},{"title":"声明式导航-跳转传参","url":"/2023/12/13/Vue2-Vue2%E5%9F%BA%E7%A1%80-%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AF%BC%E8%88%AA-%E8%B7%B3%E8%BD%AC%E4%BC%A0%E5%8F%82/","content":"1 查询参数传参1.1 配置动态路由// router/index.js中const router = new VueRouter(&#123;  routes: [    ...,    &#123;      path: &#x27;/search&#x27;,      component: Search    &#125;  ]&#125;)\n1.2 配置导航链接to=&quot;/search?参数名=参数值&quot;\n1.3 对应组件接收传递过来的值$route.query.参数名\n2 动态路由传参2.1 配置动态路由// router/index.js中const router = new VueRouter(&#123;  routes: [    ...,    &#123;      path: &#x27;/search/:参数名&#x27;,      component: Search    &#125;  ]&#125;)\n2.2 配置导航链接to=&quot;/search/参数值&quot;\n2.3 对应组件接收传递过来的值$route.params.参数名\n3 两种传参方式的区别3.1 查询参数传参比较适合传多个参数跳转：to=&quot;/path?参数名1=参数值1&amp;参数名2=参数值2&quot;获取：$route.query.参数名\n3.2 动态路由传参传单个参数比较方便配置动态路由：path: &quot;/path/:参数名&quot;跳转：to=&quot;/path/参数值&quot;获取：$route.params.参数名\n4 小问题问题：配置了路由path:&quot;/path/:id&quot;，为什么to=&quot;/path&quot;，会未匹配到组件，显示空白？原因：/path/:id表示必须要传参，如果不传参也希望匹配，可以加个可选符“？”，&#123;path: &quot;/path/:id?&quot;, component: ...&#125;\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2"]},{"title":"统一在每次请求后台时，添加 loading 效果","url":"/2023/12/12/Vue2-Vue2%E5%9F%BA%E7%A1%80-%E7%BB%9F%E4%B8%80%E5%9C%A8%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82%E5%90%8E%E5%8F%B0%E6%97%B6%EF%BC%8C%E6%B7%BB%E5%8A%A0loading%E6%95%88%E6%9E%9C/","content":"1 配置 Axios参考方法：Axios 封装\n2 请求时打开 loading// /utils/request.js中// 添加请求拦截器request.interceptors.request.use(  function (config) &#123;    // 在发送请求之前做些什么    Toast.loading(&#123;      message: &#x27;请求中...&#x27;,      forbidClick: true,      loadingType: &#x27;spinner&#x27;,      duration: 0    &#125;)    return config  &#125;,  function (error) &#123;    // 对请求错误做些什么    return Promise.reject(error)  &#125;)\n3 响应时关闭 loading// 添加响应拦截器request.interceptors.response.use(  function (response) &#123;    const res = response.data    if (res.status !== 200) &#123;      Toast(res.message)      return Promise.reject(res.message)    &#125; else &#123;      // 清除 loading 中的效果      Toast.clear()    &#125;    // 对响应数据做点什么    return res  &#125;,  function (error) &#123;    // 对响应错误做点什么    return Promise.reject(error)  &#125;)","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Axios","Toast"]},{"title":"编程式导航","url":"/2023/12/13/Vue2-Vue2%E5%9F%BA%E7%A1%80-%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/","content":"1 基本跳转1.1 path 路径跳转1.1.1 配置路由// router/index.js中&#123;  path: &#x27;/path&#x27;,  component: ...&#125;\n1.1.2 路径跳转this.$router.push(&#x27;/path&#x27;)\n1.2 name 命名路由跳转1.2.1 配置路由// router/index.js中&#123;  name: &#x27;路由名&#x27;,  path: &#x27;/path&#x27;,  component: ...&#125;\n1.2.2 路由跳转this.$router.push(&#123;  name: &#x27;路由名&#x27;&#125;)\n2 路由传参2.1 path 路径跳转传参 - 查询参数传参2.1.1 配置路由&#123;  path: &#x27;/path&#x27;,  component: ...&#125;\n2.1.2 跳转传参this.$router.push(&#x27;/path?参数名1=参数值1&amp;参数名2=参数值2&#x27;)// 或者this.$router.push(&#123;  path: &#x27;/path&#x27;,  query: &#123;    参数名1: 参数值1,    参数名2: 参数值2  &#125;&#125;)\n2.1.3 对应组件接收传递过来的值$route.query.参数名\n2.2 path 路径跳转传参 - 动态路由传参2.2.1 配置路由&#123;  path: &#x27;/path/:参数名&#x27;,  component: ...&#125;\n2.2.2 跳转传参this.$router.push(&#x27;/path/参数值&#x27;)// 或者this.$router.push(&#123;  path: &#x27;/path/参数值&#x27;&#125;)\n2.2.3 对应组件接收传递过来的值$route.params.参数名\n2.3 name 命名路由跳转传参 - 查询参数传参2.3.1 配置路由&#123;  name: &#x27;路由名&#x27;,  path: &#x27;/path&#x27;,  component: ...&#125;\n2.3.2 跳转传参this.$router.push(&#123;  name: &#x27;路由名&#x27;,  query: &#123;    参数名1: 参数值1,    参数名2: 参数值2  &#125;&#125;)\n2.3.3 对应组件接收传递过来的值$route.query.参数名\n2.4 name 命名路由跳转传参 - 动态路由传参2.4.1 配置路由&#123;  name: &#x27;路由名&#x27;,  path: &#x27;/path/:参数名&#x27;,  component: ...&#125;\n2.4.2 跳转传参this.$router.push(&#123;  name: &#x27;路由名&#x27;,  params: &#123;    参数名: 参数值  &#125;&#125;)\n2.4.3 对应组件接收传递过来的值$route.params.参数名","categories":["Vue2","Vue2 基础"],"tags":["Vue2"]},{"title":"请求拦截器统一携带Token","url":"/2023/12/15/Vue2-Vue2%E5%9F%BA%E7%A1%80-%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8%E7%BB%9F%E4%B8%80%E6%90%BA%E5%B8%A6Token/","content":"1 配置 Axios参考方法：Axios 封装\n2 配置请求拦截器import &#123; Toast &#125; from &#x27;vant&#x27;import store from &#x27;@/store/index&#x27;...// 添加请求拦截器request.interceptors.request.use(  function (config) &#123;    // 在发送请求之前做些什么    Toast.loading(&#123;      message: &#x27;请求中...&#x27;,      forbidClick: true,      loadingType: &#x27;spinner&#x27;,      duration: 0    &#125;)    // 只要有 token，就在请求时携带，便于请求请求需要授权的接口    const token = store.getters.token    if (token) &#123;      config.headers[&#x27;Access-Token&#x27;] = token      config.headers.platform = &#x27;H5&#x27;    &#125;    return config  &#125;,  function (error) &#123;    // 对请求错误做些什么    return Promise.reject(error)  &#125;)\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Axios"]},{"title":"路由懒加载","url":"/2023/12/21/Vue2-Vue2%E5%9F%BA%E7%A1%80-%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/","content":"1 异步组件改造官网链接：https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E4%BD%BF%E7%94%A8-webpack当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。// router/index.jsconst ProDetail = () =&gt; import(&#x27;@/views/prodetail&#x27;)const Pay = () =&gt; import(&#x27;@/views/pay&#x27;)const MyOrder = () =&gt; import(&#x27;@/views/myorder&#x27;)\n2 路由中应用// router/index.js&#123; path:&#x27;/pay&#x27;, component: Pay &#125;,......\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2"]},{"title":"Vue2 中 Vant 组件库的基本使用方法","url":"/2023/12/07/Vue2%E4%B8%ADVant%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"1 安装1.1 Vant2 组件库地址&emsp;&emsp;https://vant-contrib.gitee.io/vant/v2/#/zh-CN\n1.2 通过 npm 安装# Vue 2 项目，安装 Vant 2：npm i vant@latest-v2 -S\n2 引入组件2.1 按需导入# 1.安装插件npm i babel-plugin-import -D\n// 2.babel.config.js中配置module.exports = &#123;  presets: [    &#x27;@vue/cli-plugin-babel/preset&#x27;  ],  plugins: [    [&#x27;import&#x27;, &#123;      libraryName: &#x27;vant&#x27;,      libraryDirectory: &#x27;es&#x27;,      style: true    &#125;, &#x27;vant&#x27;]  ]&#125;\n// 3.新建/src/utils/vant-ui.jsimport Vue from &#x27;vue&#x27;import &#123; Button, Switch &#125; from &#x27;vant&#x27;Vue.use(Button)Vue.use(Switch)\n// 4.main.js中import Vue from &#x27;vue&#x27;;import &#x27;@/utils/vant-ui.js&#x27;\n// 5.页面中使用测试&lt;van-button type=&quot;primary&quot;&gt;主要按钮&lt;/van-button&gt;\n2.2 全部导入// 1.main.js中import Vue from &#x27;vue&#x27;;import Vant from &#x27;vant&#x27;;import &#x27;vant/lib/index.css&#x27;;// 插件安装初始化，内部会将所有的vant组件进行导入注册Vue.use(Vant);\n// 2.页面中使用测试&lt;van-button type=&quot;primary&quot;&gt;主要按钮&lt;/van-button&gt;","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库"]},{"title":"Vue2 中 router/index.js 基础配置","url":"/2023/12/07/Vue2%E4%B8%ADrouter-index-js%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","content":"// /src/router/index.js 基础配置import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import HomeView from &#x27;../views/HomeView.vue&#x27;Vue.use(VueRouter)const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;home&#x27;,    component: HomeView  &#125;,  &#123;    path: &#x27;/about&#x27;,    name: &#x27;about&#x27;,    // route level code-splitting    // this generates a separate chunk (about.[hash].js) for this route    // which is lazy-loaded when the route is visited.    component: () =&gt;      import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/AboutView.vue&#x27;)  &#125;]const router = new VueRouter(&#123;  routes&#125;)export default router\nimport Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import Login from &#x27;@/views/login&#x27;import Layout from &#x27;@/views/layout&#x27;import Search from &#x27;@/views/search&#x27;import MyOrder from &#x27;@/views/myorder&#x27;import Pay from &#x27;@/views/pay&#x27;import ProDetail from &#x27;@/views/prodetail&#x27;import SearchList from &#x27;@/views/search/list&#x27;import Home from &#x27;@/views/layout/home.vue&#x27;import Cart from &#x27;@/views/layout/cart.vue&#x27;import Category from &#x27;@/views/layout/category.vue&#x27;import User from &#x27;@/views/layout/user.vue&#x27;Vue.use(VueRouter)const routes = [  &#123;    path: &#x27;/login&#x27;,    component: Login  &#125;,  &#123;    path: &#x27;/&#x27;,    component: Layout,    redirect: &#x27;/home&#x27;,    children: [      &#123; path: &#x27;home&#x27;, component: Home &#125;,      &#123; path: &#x27;cart&#x27;, component: Cart &#125;,      &#123; path: &#x27;user&#x27;, component: User &#125;,      &#123; path: &#x27;category&#x27;, component: Category &#125;    ]  &#125;,  &#123;    path: &#x27;/search&#x27;,    component: Search  &#125;,  &#123;    path: &#x27;/pay&#x27;,    component: Pay  &#125;,  &#123;    path: &#x27;/myorder&#x27;,    component: MyOrder  &#125;,  &#123;    path: &#x27;/prodetail:id&#x27;,    component: ProDetail  &#125;,  &#123;    path: &#x27;/searchlist&#x27;,    component: SearchList  &#125;]const router = new VueRouter(&#123;  routes&#125;)export default router","categories":["Vue2","Vue2 基础"],"tags":["Vue2","vue-router"]},{"title":"图片懒加载指令实现","url":"/2024/01/08/Vue3-Vue3%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0/","content":"1 自定义懒加载指令自定义指令官方文档：https://cn.vuejs.org/guide/reusability/custom-directives.htmlVueUse 的 useIntersectionObserver 方法官方文档：https://www.vueusejs.com/core/useIntersectionObserver/\n// main.js// 用到了VueUse的useIntersectionObserver方法import &#123; useIntersectionObserver &#125; from &#x27;@vueuse/core&#x27;const app = createApp(App)app.directive(&#x27;img-lazy&#x27;, &#123;  mounted(el, binding) &#123;    // console.log(el, binding.value)    const &#123; stop &#125; = useIntersectionObserver(el, ([&#123; isIntersecting &#125;]) =&gt; &#123;      // console.log(isIntersecting)      if (isIntersecting) &#123;        el.src = binding.value        stop()      &#125;    &#125;)  &#125;&#125;)\n// 组件中使用&lt;img v-img-lazy=&quot;item.picture&quot; alt=&quot;&quot; /&gt;\n2 把自定义指令抽离成一个插件自定义插件官方文档：https://cn.vuejs.org/guide/reusability/plugins.html\n// src/directives/index.js// 定义懒加载插件import &#123; useIntersectionObserver &#125; from &#x27;@vueuse/core&#x27;export const lazyPlugin = &#123;  install(app) &#123;    // 懒加载指令逻辑    app.directive(&#x27;img-lazy&#x27;, &#123;      mounted(el, binding) &#123;        // console.log(el, binding.value)        const &#123; stop &#125; = useIntersectionObserver(el, ([&#123; isIntersecting &#125;]) =&gt; &#123;          console.log(isIntersecting)          if (isIntersecting) &#123;            el.src = binding.value            stop()          &#125;        &#125;)      &#125;    &#125;)  &#125;&#125;\n// main.jsimport &#123; lazyPlugin &#125; from &#x27;@/directives/index.js&#x27;const app = createApp(App)app.use(lazyPlugin)// ......\n","categories":["Vue3","Vue3 基础"],"tags":["Vue3","VueUse"]},{"title":"使用 VueUse 的 useIntersectionObserver 监听目标元素的可见性","url":"/2024/01/08/Vue3-VueUse-%E4%BD%BF%E7%94%A8VueUse%E7%9A%84useIntersectionObserver%E7%9B%91%E5%90%AC%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/","content":"1 注册安装官网：https://www.vueusejs.com/core/useIntersectionObserver/\nnpm i @vueuse/core\n2 使用方法&lt;div ref=&quot;target&quot;&gt;  &lt;h1&gt;Hello world&lt;/h1&gt;&lt;/div&gt;\nimport &#123; ref &#125; from &#x27;vue&#x27;import &#123; useIntersectionObserver &#125; from &#x27;@vueuse/core&#x27;export default &#123;  setup() &#123;    const target = ref(null)    const targetIsVisible = ref(false)    const &#123; stop &#125; = useIntersectionObserver(      target,      ([&#123; isIntersecting &#125;], observerElement) =&gt; &#123;        targetIsVisible.value = isIntersecting      &#125;,    )    return &#123;      target,      targetIsVisible,    &#125;  &#125;,&#125;","categories":["Vue3","VueUse"],"tags":["Vue3","VueUse"]},{"title":"使用 VueUse 的 useScroll 判断页面滚动距离","url":"/2024/01/03/Vue3-VueUse-%E4%BD%BF%E7%94%A8VueUse%E7%9A%84useScroll%E5%88%A4%E6%96%AD%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E8%B7%9D%E7%A6%BB/","content":"1 注册安装官网：https://www.vueusejs.com/core/useScroll/\nnpm i @vueuse/core\n2 使用方法&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useScroll &#125; from &#x27;@vueuse/core&#x27;const el = ref&lt;HTMLElement | null&gt;(null)const &#123; x, y, isScrolling, arrivedState, directions &#125; = useScroll(el)&lt;/script&gt;&lt;template&gt;  &lt;div ref=&quot;el&quot;&gt;&lt;/div&gt;&lt;/template&gt;\n&lt;script setup&gt;// vueUseimport &#123; useScroll &#125; from &#x27;@vueuse/core&#x27;const &#123; y &#125; = useScroll(window)&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;app-header-sticky&quot; :class=&quot;&#123; show: y &gt; 78 &#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt;\n","categories":["Vue3","VueUse"],"tags":["Vue3","VueUse"]},{"title":"Vue3 中 router/index.js 基础配置","url":"/2024/01/02/Vue3%E4%B8%ADrouter-index-js%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","content":"// createRouter: 创建router实例对象// createWebHistory: 创建History模式的路由import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;import HomeView from &#x27;../views/HomeView.vue&#x27;const router = createRouter(&#123;  history: createWebHistory(import.meta.env.BASE_URL),  routes: [    &#123;      path: &#x27;/&#x27;,      name: &#x27;home&#x27;,      component: HomeView    &#125;,    &#123;      path: &#x27;/about&#x27;,      name: &#x27;about&#x27;,      // route level code-splitting      // this generates a separate chunk (About.[hash].js) for this route      // which is lazy-loaded when the route is visited.      component: () =&gt; import(&#x27;../views/AboutView.vue&#x27;)    &#125;  ]&#125;)export default router\nimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;import Layout from &#x27;@/views/layout/index.vue&#x27;import Login from &#x27;@/views/login/index.vue&#x27;const router = createRouter(&#123;  history: createWebHistory(import.meta.env.BASE_URL),  routes: [    &#123;      path: &#x27;/&#x27;,      component: Layout    &#125;,    &#123;      path: &#x27;/login&#x27;,      component: Login    &#125;  ]&#125;)export default router","categories":["Vue3","Vue3 基础"],"tags":["vue-router","Vue3"]},{"title":"XR-FRAME - 基础能力 - Alpha 透明画布","url":"/2023/12/12/XR-FRAME-%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-Alpha%E9%80%8F%E6%98%8E%E7%94%BB%E5%B8%83/","content":"1 项目地址官方项目地址：https://github.com/dtysky/xr-frame-demo/tree/master/miniprogram/components/xr-basic-alpha\n2 代码解析主要代码：&lt;xr-scene render-system=&quot;alpha:true&quot; bind:ready=&quot;handleReady&quot;&gt;  &lt;xr-node&gt;    &lt;xr-mesh id=&quot;cube&quot; node-id=&quot;mesh-cube&quot; position=&quot;-0.5 0 0&quot; geometry=&quot;cube&quot; uniforms=&quot;u_baseColorFactor:0.298 0.764 0.85 &#123;&#123;cubeAlpha&#125;&#125;&quot; states=&quot;alphaMode:BLEND&quot; /&gt;    &lt;xr-mesh node-id=&quot;mesh-sphere&quot; position=&quot;0.5 0 0&quot; geometry=&quot;sphere&quot; uniforms=&quot;u_baseColorFactor:0.937 0.176 0.368 &#123;&#123;sphereAlpha&#125;&#125;&quot; states=&quot;alphaMode:BLEND&quot; /&gt;    &lt;xr-node node-id=&quot;target&quot; position=&quot;0 0 0&quot; /&gt;    &lt;xr-camera      id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;0 2 2&quot; clear-color=&quot;&#123;&#123;clearColor&#125;&#125;&quot;      target=&quot;target&quot; camera-orbit-control=&quot;&quot;    &gt;&lt;/xr-camera&gt;  &lt;/xr-node&gt;  &lt;xr-node node-id=&quot;lights&quot;&gt;    &lt;xr-light type=&quot;ambient&quot; color=&quot;1 1 1&quot; intensity=&quot;1&quot; /&gt;    &lt;xr-light type=&quot;directional&quot; rotation=&quot;40 170 0&quot; color=&quot;1 1 1&quot; intensity=&quot;3&quot; /&gt;  &lt;/xr-node&gt;&lt;/xr-scene&gt;\n&emsp;&emsp;这段代码中开启了 render-system 的 alpha 属性，并且将 xr-camera 元素上的 clear-color 的透明通道设置了一个非零的值，还开启了 xr-mesh 的 BLEND 混合和设置了 baseColor 的透明通道。&emsp;&emsp;有时候需要让画布有一定的透明度，来和画布后面的背景混合，即render-system=&quot;alpha:true&quot;。render-system 为渲染系统；alpha，是否支持画布输出透明通道，并且能够和背景混合。xml 中数据类型为 boolean。&emsp;&emsp;states=&quot;alphaMode:BLEND&quot;给网格开启透明混合。states 为初始要写入的渲染状态，xml 中的数据类型为 map，目前支持 renderQueue、cullOn、depthTestOn、depthTestWrite、alphaMode、alphaCutOff，alphaMode 和 alphaCutOff 遵循 glTF 标准；alphaMode，透明模式，材质支持的渲染状态，类型有 ‘OPAQUE’、’BLEND’、’MASK’。\n","categories":["微信小程序","xr-frame"],"tags":["微信小程序","xr-frame"]},{"title":"XR-FRAME - 基础能力 - Geometry 基础图形","url":"/2023/12/11/XR-FRAME-%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-Geometry%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2/","content":"1 项目地址官方项目地址：https://github.com/dtysky/xr-frame-demo/tree/master/miniprogram/components/xr-basic\n2 代码解析主要代码：&lt;xr-scene id=&quot;xr-scene&quot; bind:ready=&quot;handleReady&quot;&gt;  &lt;xr-assets bind:progress=&quot;handleAssetsProgress&quot; bind:loaded=&quot;handleAssetsLoaded&quot;&gt;    &lt;xr-asset-material asset-id=&quot;standard-mat&quot; effect=&quot;standard&quot; /&gt;  &lt;/xr-assets&gt;  &lt;xr-node&gt;    &lt;xr-mesh node-id=&quot;mesh-plane&quot; position=&quot;0 -0.02 -4&quot; rotation=&quot;0 0 0&quot; scale=&quot;5 1 5&quot; geometry=&quot;plane&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.48 0.78 0.64 1&quot; receive-shadow&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh id=&quot;cube&quot; node-id=&quot;mesh-cube&quot; position=&quot;-1 0.5 -3.5&quot; scale=&quot;1 1 1&quot; rotation=&quot;0 45 0&quot; geometry=&quot;cube&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.298 0.764 0.85 1&quot; cast-shadow&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh node-id=&quot;mesh-cylinder&quot; position=&quot;1 0.7 -3.5&quot; scale=&quot;1 0.7 1&quot; geometry=&quot;cylinder&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:1 0.776 0.364 1&quot; cast-shadow&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh node-id=&quot;mesh-sphere&quot; position=&quot;0 1.25 -5&quot; scale=&quot;1.25 1.25 1.25&quot; geometry=&quot;sphere&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.937 0.176 0.368 1&quot; cast-shadow&gt;&lt;/xr-mesh&gt;    &lt;xr-camera      id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;0 1.6 0&quot; clear-color=&quot;0.925 0.925 0.925 1&quot;      target=&quot;mesh-sphere&quot;      camera-orbit-control=&quot;&quot;    &gt;&lt;/xr-camera&gt;  &lt;/xr-node&gt;  &lt;xr-node node-id=&quot;lights&quot;&gt;    &lt;xr-light type=&quot;ambient&quot; color=&quot;1 1 1&quot; intensity=&quot;1&quot; /&gt;    &lt;xr-light type=&quot;directional&quot; rotation=&quot;40 170 0&quot; color=&quot;1 1 1&quot; intensity=&quot;3&quot; cast-shadow/&gt;  &lt;/xr-node&gt;&lt;/xr-scene&gt;\n2.1 xr-scene&emsp;&emsp;对于所有的 xr-frame 小程序组件，其最外层必须有一个xr-scene标签作为根元素，并且组件内只能有一个，以此作为整个组件的基础。&emsp;&emsp;在编写组件时，常常用到的那个 this.scene，其实就是这个元素。&emsp;&emsp;可用来添加事件，如 ready 事件，场景第一次解析完毕。\n2.2 xr-assets&emsp;&emsp;用于包裹所需要加载的资源，可以绑定事件。\n2.3 xr-asset-material&emsp;&emsp;材质：asset-id 为材质的 id，可以用于给下面的 xr-mesh 进行绑定；effect 用于指定材质的效果，一般选 standard 即可。\n2.4 xr-mesh&emsp;&emsp;网格：geometry 用于指定所要加载的物体的形状；node-id 为物体的 id，可以用于给 xr-camera 进行绑定，以确定相机朝向；material 可以用于绑定对应的材质 id；uniforms 是渲染相关的属性；cast-shadow 用于产生阴影，receive-shadow 用于接收其他物体产生的阴影，并且需要给灯光也开启 cast-shadow 效果。\n&emsp;&emsp;其中 geometry 是必传的，值为注册过的几何数据的资源id。material 是创建过的材质的资源id，如果不写则会默认使用一个标准的使用了 standard 效果的材质。\n&emsp;&emsp;uniforms 和 states 比较特殊，它们其实是材质的数据，但为了方便开发者使用，不去给每一个网格都创建一个材质，所以提供了这样的一种方式。在这种方式下，会自动拷贝一份材质，对材质的修改不会影响到原始材质，同时对原始材质的修改也不会影响到这个网格，这点一定要注意！\n2.5 xr-camera&emsp;&emsp;相机：clear-color 为相机底色；target 为相机朝向，可以绑定相应物体的 id；camera-orbit-control，相机控制器组件提供了一个简单的绕着相机 target 旋转的控制方式，一般而言只需要在元素上添加 camera-orbit-control 属性即可。\n2.6 xr-light&emsp;&emsp;灯光：type，灯光类型；color，灯光颜色；intensity，灯光亮度；rotation，灯光方向；cast-shadow，允许灯光产生阴影效果，只有主平行光能够产生阴影，相对应的 receive-shadow 去接收阴影。\n","categories":["微信小程序","xr-frame"],"tags":["微信小程序","xr-frame"]},{"title":"XR-FRAME - 基础能力 - Interactions 交互","url":"/2023/12/14/XR-FRAME-%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-Interaction%E4%BA%A4%E4%BA%92/","content":"1 项目地址官方项目地址：https://github.com/dtysky/xr-frame-demo/tree/master/miniprogram/components/xr-basic-touch\n2 代码解析主要代码：&lt;xr-scene id=&quot;xr-scene&quot; bind:tick=&quot;handleTick&quot; bind:ready=&quot;handleReady&quot;&gt;  &lt;xr-assets bind:progress=&quot;handleAssetsProgress&quot; bind:loaded=&quot;handleAssetsLoaded&quot;&gt;    &lt;xr-asset-load type=&quot;texture&quot; asset-id=&quot;earth-texture&quot; src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/2k_earth_daymap.jpeg&quot; /&gt;    &lt;xr-asset-load type=&quot;texture&quot; asset-id=&quot;moon-texture&quot; src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/2k_moon.jpeg&quot; /&gt;    &lt;xr-asset-load type=&quot;texture&quot; asset-id=&quot;sky&quot; src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/dark-cosmos.jpg&quot; /&gt;    &lt;xr-asset-material asset-id=&quot;standard-mat&quot; effect=&quot;standard&quot; /&gt;    &lt;xr-asset-material asset-id=&quot;earth-mat&quot; effect=&quot;standard&quot; uniforms=&quot;u_baseColorMap: earth-texture&quot; render-queue=&quot;501&quot;/&gt;    &lt;xr-asset-material asset-id=&quot;earth-silhouette&quot; effect=&quot;simple&quot; uniforms=&quot;u_baseColorFactor: 1.0 0.5 0 1.0&quot; states=&quot;depthTestWrite: false&quot; render-queue=&quot;500&quot;/&gt;    &lt;xr-asset-material asset-id=&quot;moon-mat&quot; effect=&quot;standard&quot; uniforms=&quot;u_baseColorMap: moon-texture&quot; render-queue=&quot;503&quot;/&gt;    &lt;xr-asset-material asset-id=&quot;moon-silhouette&quot; effect=&quot;simple&quot; uniforms=&quot;u_baseColorFactor: 0.476 0.82 0.957 1.0&quot; states=&quot;depthTestWrite: false&quot; render-queue=&quot;502&quot;/&gt;  &lt;/xr-assets&gt;  &lt;xr-env sky-map=&quot;sky&quot; is-sky2d/&gt;  &lt;xr-node&gt;    &lt;xr-mesh node-id=&quot;mesh-earth&quot; position=&quot;0 0 0&quot; scale=&quot;8 8 8&quot; geometry=&quot;sphere&quot; material=&quot;earth-mat&quot; bind:touch-shape=&quot;handleTouchEarth&quot; bind:untouch-shape=&quot;handleUntouchEarth&quot; bind:drag-shape=&quot;handleEarthRotation&quot; sphere-shape receive-shadow cast-shadow&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh node-id=&quot;earth-silhouette&quot; scale=&quot;8.15 8.15 8.15&quot; geometry=&quot;sphere&quot; material=&quot;earth-silhouette&quot; visible=&quot;&#123;&#123;touchingEarth&#125;&#125;&quot;&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh node-id=&quot;mesh-moon&quot; position=&quot;10 0 0&quot; scale=&quot;1.5 1.5 1.5&quot; rotation=&quot;0 90 0&quot; geometry=&quot;sphere&quot; material=&quot;moon-mat&quot; bind:drag-shape=&quot;handleDragMoon&quot; bind:touch-shape=&quot;handleTouchMoon&quot; bind:untouch-shape=&quot;handleUntouchMoon&quot; sphere-shape=&quot;radius: 1.5&quot; receive-shadow cast-shadow&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh node-id=&quot;moon-silhouette&quot; scale=&quot;1.1 1.1 1.1&quot; geometry=&quot;sphere&quot; material=&quot;moon-silhouette&quot; visible=&quot;&#123;&#123;touchingMoon&#125;&#125;&quot;&gt;&lt;/xr-mesh&gt;    &lt;xr-camera      id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;0 20 -35&quot; clear-color=&quot;0 0 0 1&quot;      target=&quot;mesh-earth&quot;      background=&quot;skybox&quot;    &gt;&lt;/xr-camera&gt;  &lt;/xr-node&gt;  &lt;xr-node node-id=&quot;lights&quot;&gt;    &lt;xr-light type=&quot;ambient&quot; color=&quot;1 1 1&quot; intensity=&quot;0.1&quot; /&gt;    &lt;xr-light id=&quot;directional-light&quot; type=&quot;directional&quot; rotation=&quot;0 60 0&quot; color=&quot;1 1 1&quot; intensity=&quot;5&quot;  shadow-distance=&quot;40&quot; cast-shadow shadow-bias=&quot;0.004&quot;/&gt;  &lt;/xr-node&gt;&lt;/xr-scene&gt;\nComponent(&#123;  behaviors: [require(&#x27;../common/share-behavior&#x27;).default],  properties: &#123;    a: Number,  &#125;,  data: &#123;    loaded: false,    touchingMoon: false,    touchingEarth: false,    θ: Math.PI,    r: 10,    ω: 5e-4,    outerRing: 20,    innerRing: 10  &#125;,  lifetimes: &#123;&#125;,  methods: &#123;    handleReady(&#123;detail&#125;) &#123;      const xrScene = this.scene = detail.value;      console.log(&#x27;xr-scene&#x27;, xrScene);    &#125;,    handleAssetsProgress: function(&#123;detail&#125;) &#123;      console.log(&#x27;assets progress&#x27;, detail.value);    &#125;,    handleAssetsLoaded: function(&#123;detail&#125;) &#123;      console.log(&#x27;assets loaded&#x27;, detail.value);      this.setData(&#123;loaded: true&#125;);    &#125;,    handleTouchEarth: function() &#123;      this.setData(&#123;        touchingEarth: true      &#125;);    &#125;,    handleUntouchEarth: function() &#123;      this.setData(&#123;        touchingEarth: false      &#125;);    &#125;,    handleEarthRotation: function(&#123;detail&#125;) &#123;        const &#123; target, deltaX &#125; = detail.value;        target._components.transform.rotation.y += deltaX / 100;    &#125;,    handleDragMoon: function(&#123;detail&#125;) &#123;        const &#123; dir, target, camera &#125; = detail.value;        const cameraPos = camera.el._components.transform.worldPosition;        const k = -cameraPos.y / dir[1];        const x = cameraPos.x + k * dir[0];        const z = cameraPos.z + k * dir[2];        const len = Math.sqrt(x * x + z * z);        if (len &gt; this.data.innerRing) &#123;            const transform = target._components.transform;            const scale = len &gt; this.data.outerRing ? this.data.outerRing / len : 1.0;            transform.position.x = x * scale;            transform.position.z = z * scale;        &#125;    &#125;,    handleTouchMoon: function() &#123;        this.setData(&#123;touchingMoon: true&#125;);    &#125;,    handleUntouchMoon: function() &#123;        const moon = this.scene.getNodeById(&quot;mesh-moon&quot;);        const transform = moon.el._components.transform;        const x = transform.position.x;        const z = transform.position.z;        const len = Math.sqrt(x * x + z * z);        this.setData(&#123;            r: len,            θ: x &lt; 0 ? Math.atan(z / x) + Math.PI : Math.atan(z / x),            ω: Math.sqrt(2.5e-4 / (len * len * len))        &#125;);        this.setData(&#123;touchingMoon: false&#125;);    &#125;,    handleTick: function(&#123;detail&#125;) &#123;        if (this.data.touchingMoon || !this.scene) return;        const deltaTime = detail.value;        const moon = this.scene.getNodeById(&quot;mesh-moon&quot;);        const transform = moon.el._components.transform;        const x = Math.cos(this.data.θ) * this.data.r;        const z = Math.sin(this.data.θ) * this.data.r;        transform.position.x = x;        transform.position.z = z;        transform.rotation.y -= this.data.ω * deltaTime;        this.setData(&#123;            θ: this.data.θ + this.data.ω * deltaTime        &#125;);    &#125;  &#125;&#125;)\n2.1 地球模块2.1.1 地球 - 加载资源&lt;xr-asset-load type=&quot;texture&quot; asset-id=&quot;earth-texture&quot; src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/2k_earth_daymap.jpeg&quot; /&gt;&lt;xr-asset-material asset-id=&quot;earth-mat&quot; effect=&quot;standard&quot; uniforms=&quot;u_baseColorMap: earth-texture&quot; render-queue=&quot;501&quot;/&gt;&lt;xr-asset-material asset-id=&quot;earth-silhouette&quot; effect=&quot;simple&quot; uniforms=&quot;u_baseColorFactor: 1.0 0.5 0 1.0&quot; states=&quot;depthTestWrite: false&quot; render-queue=&quot;500&quot;/&gt;\n&emsp;&emsp;首先去加载图片，命名 asset-id 为 earth-texture；之后加载了两种材质，材质 earth-mat 用于生成地球网格，通过 uniforms 绑定了刚刚加载的图片 earth-texture，材质 earth-silhouette 用于生成点击地球时出现的轮廓的网格。\n2.1.2 地球 - 生成网格&lt;xr-mesh node-id=&quot;mesh-earth&quot; position=&quot;0 0 0&quot; scale=&quot;8 8 8&quot; geometry=&quot;sphere&quot; material=&quot;earth-mat&quot; bind:touch-shape=&quot;handleTouchEarth&quot; bind:untouch-shape=&quot;handleUntouchEarth&quot; bind:drag-shape=&quot;handleEarthRotation&quot; sphere-shape receive-shadow cast-shadow&gt;&lt;/xr-mesh&gt;&lt;xr-mesh node-id=&quot;earth-silhouette&quot; scale=&quot;8.15 8.15 8.15&quot; geometry=&quot;sphere&quot; material=&quot;earth-silhouette&quot; visible=&quot;&#123;&#123;touchingEarth&#125;&#125;&quot;&gt;&lt;/xr-mesh&gt;\n&emsp;&emsp;通过 material 绑定不同的材质，生成了地球网格和轮廓网格。\n2.1.3 地球 - 事件解析handleTouchEarth: function() &#123;  this.setData(&#123;    touchingEarth: true  &#125;);&#125;,handleUntouchEarth: function() &#123;  this.setData(&#123;    touchingEarth: false  &#125;);&#125;,handleEarthRotation: function(&#123;detail&#125;) &#123;    const &#123; target, deltaX &#125; = detail.value;    target._components.transform.rotation.y += deltaX / 100;&#125;,\n&emsp;&emsp;地球网格上绑定了三个事件处理函数：&emsp;&emsp;通过手指的触摸与松开地球网格，触发的事件函数 handleTouchEarth 和事件函数 handleUntouchEarth，可以改变轮廓网格上绑定的 touchingEarth 的值，来控制轮廓网格的现实与隐藏。&emsp;&emsp;通过手指对地球网格的拖拽，触发的事件函数 handleEarthRotation，可以改变地球的角度。其中 target 可以获取到地球网格，deltaX 为用户手指在屏幕上划过的距离，按照一定的比例，通过 deltaX 来改变地球网格的 transform.rotation.y，使得地球网格旋转起来。\n2.2 月球模块2.2.1 月球 - 加载资源&lt;xr-asset-load type=&quot;texture&quot; asset-id=&quot;moon-texture&quot; src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/2k_moon.jpeg&quot; /&gt;&lt;xr-asset-material asset-id=&quot;moon-mat&quot; effect=&quot;standard&quot; uniforms=&quot;u_baseColorMap: moon-texture&quot; render-queue=&quot;503&quot;/&gt;&lt;xr-asset-material asset-id=&quot;moon-silhouette&quot; effect=&quot;simple&quot; uniforms=&quot;u_baseColorFactor: 0.476 0.82 0.957 1.0&quot; states=&quot;depthTestWrite: false&quot; render-queue=&quot;502&quot;/&gt;\n&emsp;&emsp;同样的方法加载资源，生成月球网格和点击时出现的轮廓的网格。\n2.2.2 月球 - 生成网格&lt;xr-mesh node-id=&quot;mesh-moon&quot; position=&quot;10 0 0&quot; scale=&quot;1.5 1.5 1.5&quot; rotation=&quot;0 90 0&quot; geometry=&quot;sphere&quot; material=&quot;moon-mat&quot; bind:drag-shape=&quot;handleDragMoon&quot; bind:touch-shape=&quot;handleTouchMoon&quot; bind:untouch-shape=&quot;handleUntouchMoon&quot; sphere-shape=&quot;radius: 1.5&quot; receive-shadow cast-shadow&gt;&lt;/xr-mesh&gt;&lt;xr-mesh node-id=&quot;moon-silhouette&quot; scale=&quot;1.1 1.1 1.1&quot; geometry=&quot;sphere&quot; material=&quot;moon-silhouette&quot; visible=&quot;&#123;&#123;touchingMoon&#125;&#125;&quot;&gt;&lt;/xr-mesh&gt;\n2.2.3 月球 - 事件解析handleDragMoon: function(&#123;detail&#125;) &#123;    const &#123; dir, target, camera &#125; = detail.value;    const cameraPos = camera.el._components.transform.worldPosition;    const k = -cameraPos.y / dir[1];    const x = cameraPos.x + k * dir[0];    const z = cameraPos.z + k * dir[2];    const len = Math.sqrt(x * x + z * z);    if (len &gt; this.data.innerRing) &#123;        const transform = target._components.transform;        const scale = len &gt; this.data.outerRing ? this.data.outerRing / len : 1.0;        transform.position.x = x * scale;        transform.position.z = z * scale;    &#125;&#125;,handleTouchMoon: function() &#123;    this.setData(&#123;touchingMoon: true&#125;);&#125;,handleUntouchMoon: function() &#123;    const moon = this.scene.getNodeById(&quot;mesh-moon&quot;);    const transform = moon.el._components.transform;    const x = transform.position.x;    const z = transform.position.z;    const len = Math.sqrt(x * x + z * z);    this.setData(&#123;        r: len,        θ: x &lt; 0 ? Math.atan(z / x) + Math.PI : Math.atan(z / x),        ω: Math.sqrt(2.5e-4 / (len * len * len))    &#125;);    this.setData(&#123;touchingMoon: false&#125;);&#125;,\n&emsp;&emsp;月球网格上绑定了三个事件处理函数：&emsp;&emsp;通过手指的触摸与松开月球网格，触发的事件函数 handleTouchMoon 和事件函数 handleUntouchMoon，可以改变轮廓网格上绑定的 touchingMoon 的值，来控制轮廓网格的现实与隐藏。当然，因为月球网格要围绕地球公转，所以在松开手指时，要更新月球到地球的距离 r、月球公转时所需要的角度 θ、公转的角速度 ω，其中ω: Math.sqrt(2.5e-4 / (len * len * len))为天体运动的基本公式，\n\nma=mω^2r=F=\\frac{GMm}{r}^2&emsp;&emsp;通过手指对月球网格的拖拽，触发的事件函数 handleDragMoon，可以改变月球到地球的距离。具体的计算方法如下：&emsp;&emsp;dir 是由相机向地球和月球所在的三维世界发射出的一条射线的单位向量，通过手指在屏幕上的滑动可以改变射线的方向，该射线与平面 $y=0$ 的交点，即为月球网格的所在位置（在不受到最大、最小距离限制时）；cameraPos 是相机的所在的坐标，即射线上的一个点；有了直线的向量和一个点，可知直线方程为:\n\n\\frac{x-cameraPos.x}{dir[0]} = \\frac{y-cameraPos.y}{dir[1]} = \\frac{z-cameraPos.z}{dir[2]}&emsp;&emsp;假设该直线与平面 $y=0$ 的交点为 $(x_{0}, 0, z_{0})$，那么可知：\n\nx_{0} = - \\frac{cameraPos.y}{dir[1]} dir[0]+cameraPos.x\nz_{0} = - \\frac{cameraPos.y}{dir[1]} dir[2]+cameraPos.z&emsp;&emsp;即与代码中的 x 与 z 对应，再计算出与地球的距离 len。当 len 小于 this.data.innerRing，手指的拖动是不会改变月球的位置的；当 len 大于 this.data.innerRing 时，将刚刚计算出的 x 与 z 赋值给月球网格的 transform，来改变月球网格的坐标；但当 len 大于 this.data.outerRing 时，按照一定的比例 scale，去改变月球的 transform。\nhandleTick: function(&#123;detail&#125;) &#123;  if (this.data.touchingMoon || !this.scene) return;  const deltaTime = detail.value;  const moon = this.scene.getNodeById(&quot;mesh-moon&quot;);  const transform = moon.el._components.transform;  const x = Math.cos(this.data.θ) * this.data.r;  const z = Math.sin(this.data.θ) * this.data.r;  transform.position.x = x;  transform.position.z = z;  transform.rotation.y -= this.data.ω * deltaTime;  this.setData(&#123;    θ: this.data.θ + this.data.ω * deltaTime  &#125;);&#125;\n&emsp;&emsp;最后的函数 handleTick 绑定给了 xr-scene，来实现月球公转和触碰月球时停止公转的操作。\n","categories":["微信小程序","xr-frame"],"tags":["微信小程序","xr-frame"]},{"title":"XR-FRAME - 基础能力 - Animation 动画","url":"/2023/12/13/XR-FRAME-%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-Animation%E5%8A%A8%E7%94%BB/","content":"1 项目地址官方项目地址：https://github.com/dtysky/xr-frame-demo/tree/master/miniprogram/components/xr-basic-animation\n2 代码解析主要代码：\nindex.wxml 文件&lt;xr-scene id=&quot;xr-scene&quot; bind:ready=&quot;handleReady&quot;&gt;  &lt;xr-assets bind:progress=&quot;handleAssetsProgress&quot; bind:loaded=&quot;handleAssetsLoaded&quot;&gt;    &lt;xr-asset-load asset-id=&quot;basic-anim&quot; type=&quot;keyframe&quot; src=&quot;/assets/animation/basic-animation.json&quot;/&gt;    &lt;xr-asset-load type=&quot;texture&quot; asset-id=&quot;waifu&quot; src=&quot;/assets/waifu.png&quot; /&gt;    &lt;xr-asset-material asset-id=&quot;standard-mat&quot; effect=&quot;standard&quot; /&gt;  &lt;/xr-assets&gt;  &lt;xr-node&gt;    &lt;xr-node node-id=&quot;camera-target&quot; position=&quot;0 0 0&quot;&gt;&lt;/xr-node&gt;    &lt;xr-mesh      node-id=&quot;mesh-plane&quot; position=&quot;0 -0.8 0&quot; rotation=&quot;0 0 0&quot; scale=&quot;10 1 8&quot; geometry=&quot;plane&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.48 0.78 0.64 1&quot; states=&quot;cullOn: false&quot;      anim-keyframe=&quot;basic-anim&quot; anim-autoplay=&quot;clip:plane, speed:4&quot;      receive-shadow    &gt;&lt;/xr-mesh&gt;    &lt;xr-mesh      node-id=&quot;mesh-cube&quot; position=&quot;-3 0 2&quot; scale=&quot;1 1 1&quot; rotation=&quot;0 0 0&quot; geometry=&quot;cube&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.298 0.764 0.85 1&quot;      anim-keyframe=&quot;basic-anim&quot; anim-clipmap=&quot;default:cube&quot; anim-autoplay=&quot;clip:cube, speed:2&quot;      cast-shadow    &gt;&lt;/xr-mesh&gt;    ......    &lt;xr-mesh node-id=&quot;mesh-light-cube&quot; position=&quot;-5 1 0&quot; scale=&quot;0.5 10 10&quot; rotation=&quot;0 0 0&quot; geometry=&quot;cube&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.3 0.3 0.3 1, u_baseColorMap: waifu&quot;&gt;&lt;/xr-mesh&gt;    &lt;xr-camera      id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;5 3 0&quot; clear-color=&quot;0.925 0.925 0.925 1&quot;      target=&quot;camera-target&quot;      camera-orbit-control=&quot;&quot;    &gt;&lt;/xr-camera&gt;  &lt;/xr-node&gt;  &lt;xr-node node-id=&quot;lights&quot;&gt;    &lt;xr-light type=&quot;ambient&quot; color=&quot;1 1 1&quot; intensity=&quot;1&quot; /&gt;    &lt;xr-light type=&quot;directional&quot; rotation=&quot;30 230 0&quot; color=&quot;1 1 1&quot; intensity=&quot;3&quot; cast-shadow/&gt;    &lt;xr-light      type=&quot;spot&quot; position=&quot;-4 1 0&quot; rotation=&quot;0 -90 0&quot; color=&quot;0 1 0&quot; range=&quot;20&quot; intensity=&quot;100&quot; inner-cone-angle=&quot;20&quot; outer-cone-angle=&quot;60&quot;      anim-keyframe=&quot;basic-anim&quot; anim-autoplay=&quot;clip:spotLight, speed:2&quot;    /&gt;&lt;/xr-node&gt;&lt;/xr-scene&gt;\nbasic-animation.json 文件&#123;  &quot;keyframe&quot;: &#123;    &quot;cube&quot;: &#123;      &quot;0&quot;: &#123;        &quot;position&quot;: [-3, 0, 2]      &#125;,      &quot;50&quot;: &#123;        &quot;rotation&quot;: [0, 0, 0],        &quot;scale&quot;: [1, 1, 1]      &#125;,      &quot;100&quot;: &#123;        &quot;position&quot;: [3, 0, 2],        &quot;rotation&quot;: [0, 3.14, 0],        &quot;scale&quot;: [1.4, 1.4, 1.4]      &#125;    &#125;,    ......  &#125;,  &quot;animation&quot;: &#123;    &quot;default&quot;: &#123;      &quot;keyframe&quot;: &quot;cube&quot;,      &quot;duration&quot;: 1,      &quot;ease&quot;: &quot;ease-in-out&quot;,      &quot;loop&quot;: 400000,      &quot;delay&quot;: 1,      &quot;direction&quot;: &quot;both&quot;    &#125;,    ......    &quot;spotLight&quot;: &#123;      &quot;keyframe&quot;: &quot;spotLight&quot;,      &quot;duration&quot;: 2,      &quot;ease&quot;: &quot;ease-in-out&quot;,      &quot;loop&quot;: 400000,      &quot;delay&quot;: 1,      &quot;direction&quot;: &quot;both&quot;    &#125;  &#125;&#125;\n2.1 首先定义动画&emsp;&emsp;可以看到其中有两个部分：keyframe 和 animation。&emsp;&emsp;keyframe 中定义了帧动画具体的行为，本质上类似于 css3 中的 keyframes，其中进度的范围是 0~100，每个进度下是动画具体影响的键和值。属性的值仅仅支持 number、number-array 和 color 类型的数据，可以有 position、rotation、scale、material(material.u_baseColorFactor) 等。&emsp;&emsp;animation 中定义了暴露给 animator 的片段，其中第一级的每个键都是片段的名字，它对应的值就是其作为动画播放时的一些参数。keyframe 定义这个片段对应于上面定义的哪个 keyframe，duration 是以秒为单位的时长，loop 是默认循环次数（-1为永远循环），delay 是播放延迟，direction 是播放方向，默认 forwards，可选 backwards 和 both（在循环时交替前向反向），ease 则是时间函数，决定动画的插值曲线。\n2.2 把动画作为资源引入 xml&lt;xr-asset-load asset-id=&quot;basic-anim&quot; type=&quot;keyframe&quot; src=&quot;/assets/animation/basic-animation.json&quot;/&gt;\n&emsp;&emsp;其中 asset-id 为给资源绑定的 id，type 为 keyframe 类型。\n2.3 给 mesh 或 light 等绑定动画&lt;xr-mesh  node-id=&quot;mesh-cube&quot; position=&quot;-3 0 2&quot; scale=&quot;1 1 1&quot; rotation=&quot;0 0 0&quot; geometry=&quot;cube&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.298 0.764 0.85 1&quot;  anim-keyframe=&quot;basic-anim&quot; anim-clipmap=&quot;default:cube&quot; anim-autoplay=&quot;clip:cube, speed:2&quot;  cast-shadow&gt;&lt;/xr-mesh&gt;&lt;xr-light  type=&quot;spot&quot; position=&quot;-4 1 0&quot; rotation=&quot;0 -90 0&quot; color=&quot;0 1 0&quot; range=&quot;20&quot; intensity=&quot;100&quot; inner-cone-angle=&quot;20&quot; outer-cone-angle=&quot;60&quot;  anim-keyframe=&quot;basic-anim&quot; anim-autoplay=&quot;clip:spotLight, speed:2&quot;/&gt;\n&emsp;&emsp;其中 anim-keyframe 绑定了 asset-id，anim-autoplay 绑定了动画名。&emsp;&emsp;anim-autoplay 指定了是否要默认播放以及默认播放的片段和参数，如果不写 clip 数据则会播放所有的片段。anim-clipmap 则是给默认加载的动画指定一个片段映射，而这个默认的动画就是 anim-keyframe 指定的。\n","categories":["微信小程序","xr-frame"],"tags":["微信小程序","xr-frame"]},{"title":"XR-FRAME - 基础能力 - Light 多光源","url":"/2023/12/12/XR-FRAME-%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-Light%E5%A4%9A%E5%85%89%E6%BA%90/","content":"1 项目地址官方项目地址：https://github.com/dtysky/xr-frame-demo/tree/master/miniprogram/components/xr-basic-light\n2 代码解析主要代码：&lt;xr-scene id=&quot;xr-scene&quot; bind:ready=&quot;handleReady&quot;&gt;  &lt;xr-assets bind:progress=&quot;handleAssetsProgress&quot; bind:loaded=&quot;handleAssetsLoaded&quot;&gt;    &lt;xr-asset-material asset-id=&quot;standard-mat&quot; effect=&quot;standard&quot; /&gt;  &lt;/xr-assets&gt;  &lt;xr-node&gt;    &lt;xr-node node-id=&quot;camera-target&quot; position=&quot;0 0 0&quot;&gt;&lt;/xr-node&gt;    &lt;xr-mesh node-id=&quot;mesh-cube-floor&quot; position=&quot;2 -1.01 0&quot; rotation=&quot;0 0 0&quot; scale=&quot;10 1 10&quot; geometry=&quot;cube&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.2 0.2 0.2 1&quot; states=&quot;cullOn: false&quot;&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh node-id=&quot;mesh-cube&quot; position=&quot;0.6 -0.25 0.8&quot; rotation=&quot;0 30 0&quot; scale=&quot;0.5 0.5 0.5&quot; geometry=&quot;cube&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:1 1 1 1&quot;&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh node-id=&quot;mesh-sphere&quot; position=&quot;2 -0.15 -1&quot; scale=&quot;0.4 0.4 0.4&quot; geometry=&quot;sphere&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:1 1 1 1&quot;&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh node-id=&quot;mesh-cylinder&quot; position=&quot;-0.2 -0.2 -0.8&quot; scale=&quot;0.5 0.4 0.5&quot; geometry=&quot;cylinder&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:1 1 1 1&quot;&gt;&lt;/xr-mesh&gt;    &lt;xr-mesh node-id=&quot;mesh-cube-far&quot; position=&quot;3 -0.25 1&quot; rotation=&quot;0 -30 0&quot; scale=&quot;0.5 0.5 0.5&quot; geometry=&quot;cube&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:1 1 1 1&quot;&gt;&lt;/xr-mesh&gt;    &lt;xr-camera      id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;-2 1 0&quot; clear-color=&quot;0 0 0 1&quot;      target=&quot;camera-target&quot;      camera-orbit-control=&quot;&quot;    &gt;&lt;/xr-camera&gt;  &lt;/xr-node&gt;  &lt;xr-node node-id=&quot;lights&quot;&gt;    &lt;xr-light type=&quot;ambient&quot; color=&quot;1 1 1&quot; intensity=&quot;0.1&quot; /&gt;    &lt;xr-light type=&quot;directional&quot; rotation=&quot;40 170 0&quot; color=&quot;1 1 1&quot; intensity=&quot;0.2&quot; /&gt;    &lt;xr-light type=&quot;point&quot; position=&quot;0 0 0&quot; color=&quot;1 0 0&quot; range=&quot;3&quot; intensity=&quot;3&quot; /&gt;    &lt;xr-light type=&quot;point&quot; position=&quot;2 0 1&quot; color=&quot;0 1 0&quot; range=&quot;3&quot; intensity=&quot;3&quot; /&gt;    &lt;xr-light type=&quot;spot&quot; position=&quot;0 0 0&quot; color=&quot;0 0 1&quot; range=&quot;12&quot; intensity=&quot;12&quot; rotation=&quot;0 120 0&quot; inner-cone-angle=&quot;30&quot; outer-cone-angle=&quot;35&quot; /&gt;  &lt;/xr-node&gt;&lt;/xr-scene&gt;\n2.1 灯光&emsp;&emsp;环境光：类型是 ambient，支持颜色 color 和亮度 intensity，直接影响物体的基础颜色和亮度。&emsp;&emsp;平行光：类型是 directional，支持颜色 color 和亮度 intensity，以及通过旋转 rotation 决定的方向，为物体表面通过不同光照算法提供明暗。&emsp;&emsp;点光源：类型是 point，支持颜色 color 和亮度 intensity，以及 position 决定的位置和 range 决定的照亮范围。&emsp;&emsp;聚光灯：类型是 spot，支持颜色 color 和亮度 intensity，以及 position 决定的位置、rotation 决定的方向、range 决定的照亮范围，和 inner-cone-angle 与 outer-cone-angle 决定的锥角。\n2.2 阴影&emsp;&emsp;阴影是灯光和网格的协作结果，只有主平行光能够产生阴影。&emsp;&emsp;给需要接收阴影的 xr-mesh 开启 receive-shadow，给需要产生阴影的 xr-mesh 开启 cast-shadow，最后开启主光源的 cast-shadow 总开关允许灯光产生阴影。\n","categories":["微信小程序","xr-frame"],"tags":["微信小程序","xr-frame"]},{"title":"XR-FRAME - 基础能力 - Share 录屏和截屏","url":"/2023/12/15/XR-FRAME-%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-Share%E5%BD%95%E5%B1%8F%E5%92%8C%E6%88%AA%E5%B1%8F/","content":"1 项目地址官方项目地址：https://github.com/dtysky/xr-frame-demo/tree/master/miniprogram/components/xr-basic-share\n2 代码解析主要代码：&lt;!-- wxml文件里的代码较为简单，加载了一个gltf时钟 --&gt;&lt;xr-scene bind:ready=&quot;handleReady&quot;&gt;  &lt;xr-asset-load type=&quot;gltf&quot; asset-id=&quot;clock&quot; src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/clock/scene.gltf&quot; /&gt;  &lt;xr-light type=&quot;ambient&quot; color=&quot;1 1 1&quot; intensity=&quot;1&quot; /&gt;  &lt;xr-light type=&quot;directional&quot; rotation=&quot;40 70 0&quot; color=&quot;1 1 1&quot; intensity=&quot;3&quot; cast-shadow /&gt;  &lt;slot&gt;&lt;/slot&gt;    &lt;xr-gltf model=&quot;clock&quot; scale=&quot;0.1 0.1 0.1&quot; rotation=&quot;90 0 0&quot; anim-autoplay /&gt;  &lt;xr-node node-id=&quot;target&quot;&gt;&lt;/xr-node&gt;  &lt;xr-camera node-id=&quot;camera&quot; clear-color=&quot;0.4 0.8 0.6 1&quot; position=&quot;0 0 4&quot; target=&quot;target&quot; camera-orbit-control /&gt;&lt;/xr-scene&gt;\n// 主要逻辑在js中Component(&#123;  behaviors: [require(&#x27;../common/share-behavior&#x27;).default],  // 父传子，父组件传递的参数  properties: &#123;  \t// captureState用来控制截图    captureState: &#123;      type: Number,      value: 0,      observer: function (newVal, oldVal) &#123;        if (newVal !== oldVal) &#123;          if (newVal === 1) &#123;            // captureState为1时进行截图操作            this.capture();          &#125;        &#125;      &#125;,    &#125;,    // recordState用来控制录屏    recordState: &#123;      type: Number,      value: 0,      observer: function (newVal, oldVal) &#123;        if (newVal !== oldVal) &#123;          if (newVal === 0) &#123;          \t// recordState为0时录屏结束            this.recordEnd();          &#125; else &#123;          \t// recordState为1时录屏开始            this.recordStart();          &#125;        &#125;      &#125;    &#125;,    // 截屏质量    captureQuality: &#123;      type: Number,      value: 0.8,    &#125;,    // 截屏格式    captureType: &#123;      type: String,      value: &#x27;jpg&#x27;,    &#125;,    // 录屏FPS    recordFPS: &#123;      type: Number,      value: 30,    &#125;,    // 录屏尺寸相关    recordWidth: &#123;      type: Number,      value: undefined,    &#125;,    // 录屏尺寸相关    recordHeight: &#123;      type: Number,      value: undefined,    &#125;,    // 录屏BPS    recordBPS: &#123;      type: Number,      value: 1000,    &#125;,  &#125;,  data: &#123;    loaded: false  &#125;,  lifetimes: &#123;&#125;,  methods: &#123;    handleReady(&#123;detail&#125;) &#123;      const scene = this.scene = detail.value;      // share.recordPause() 暂停本次录屏      const appHide = () =&gt; this.scene.share.recordPause();      // share.recordResume() 唤醒本次录屏      const appShow = () =&gt; this.scene.share.recordResume();      wx.onAppHide(appHide);      wx.onAppShow(appShow);      wx.offAppHide(appHide);      wx.offAppShow(appShow);            // 子传父，子组件向父组件传递参数      this.triggerEvent(&#x27;sceneReady&#x27;, &#123;width: scene.width, height: scene.height&#125;);    &#125;,    // 截屏    capture() &#123;      // share.captureToFriends() 直接截屏分享给好友      // filetype 输出图片编码，可选&#x27;jpg&#x27;、&#x27;png&#x27;      // quality 输出图片jpg时的品质，0~1      this.scene.share.captureToFriends(&#123;        fileType: this.data.captureType,        quality: this.data.captureQuality      &#125;);    &#125;,    // 开始录屏    recordStart() &#123;      console.log(&#x27;recordStart&#x27;)      // share.recordStart() 启动录屏      // fps 输出帧率，默认30      // videoBitsPerSecond 视频比特率，默认1000      // width 录制视频宽度      // height 录制视频高度      this.scene.share.recordStart(&#123;        fps: this.data.recordFPS,        videoBitsPerSecond: this.data.recordBPS,        width: this.data.recordWidth,        height: this.data.recordHeight      &#125;);    &#125;,    // 停止录屏    recordEnd() &#123;      console.log(&#x27;recordEnd&#x27;)      // share.recordFinishToAlbum() 录屏完成，直接保存到用户相册      this.scene.share.recordFinishToAlbum();    &#125;  &#125;&#125;)","categories":["微信小程序","xr-frame"],"tags":["微信小程序","xr-frame"]},{"title":"XR-FRAME - 基础能力 - Video视频纹理","url":"/2023/12/13/XR-FRAME-%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-Video%E8%A7%86%E9%A2%91%E7%BA%B9%E7%90%86/","content":"1 项目地址官方项目地址：https://github.com/dtysky/xr-frame-demo/tree/master/miniprogram/components/xr-basic-video\n2 代码解析主要代码：\n&lt;xr-scene id=&quot;xr-scene&quot; bind:ready=&quot;handleReady&quot;&gt;  &lt;xr-assets bind:progress=&quot;handleAssetsProgress&quot; bind:loaded=&quot;handleAssetsLoaded&quot;&gt;    &lt;xr-asset-load      type=&quot;video-texture&quot; asset-id=&quot;cat&quot;      src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/videos/cat.mp4&quot; options=&quot;autoPlay:true,loop:true,abortAudio:false,placeHolder:https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/videos/cat.jpg&quot;    /&gt;    &lt;xr-asset-load      type=&quot;video-texture&quot; asset-id=&quot;skybox&quot;      src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/videos/office-skybox.mp4&quot; options=&quot;autoPlay:true,loop:true,placeHolder:https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/videos/office-skybox.jpg&quot;    /&gt;    &lt;xr-asset-material asset-id=&quot;standard-mat&quot; effect=&quot;standard&quot; /&gt;  &lt;/xr-assets&gt;  &lt;xr-env sky-map=&quot;video-skybox&quot; /&gt;  &lt;xr-node&gt;    &lt;xr-node node-id=&quot;target&quot; /&gt;    &lt;xr-mesh      node-id=&quot;mesh-cube&quot; scale=&quot;1.6 0.9 0.9&quot;      geometry=&quot;cube&quot; material=&quot;standard-mat&quot;      uniforms=&quot;u_baseColorMap:video-cat&quot;      cube-shape=&quot;autoFit:true&quot;      bind:touch-shape=&quot;handleTouchCube&quot;    /&gt;    &lt;xr-camera      id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;0 0 3&quot; clear-color=&quot;0.925 0.925 0.925 1&quot;      target=&quot;target&quot; background=&quot;skybox&quot; camera-orbit-control=&quot;&quot;    &gt;&lt;/xr-camera&gt;  &lt;/xr-node&gt;  &lt;xr-node node-id=&quot;lights&quot;&gt;    &lt;xr-light type=&quot;ambient&quot; color=&quot;1 1 1&quot; intensity=&quot;1&quot; /&gt;    &lt;xr-light type=&quot;directional&quot; rotation=&quot;40 0 0&quot; color=&quot;1 1 1&quot; intensity=&quot;3&quot;/&gt;  &lt;/xr-node&gt;&lt;/xr-scene&gt;\n2.1 通过加载器创建&lt;xr-asset-load  type=&quot;video-texture&quot; asset-id=&quot;cat&quot;  src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/videos/cat.mp4&quot;   options=&quot;autoPlay:true,loop:true,abortAudio:false,placeHolder:https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/videos/cat.jpg&quot;/&gt;// 或者使用代码加载视频scene.assets.loadAsset(&#123;  type: &#x27;video-texture&#x27;, assetId: &#x27;vt&#x27;, src: &#x27;/assets/video.mp4&#x27;,  options: &#123;autoPlay: true&#125;&#125;);\n&emsp;&emsp;注意到视频纹理的几个选项，autoPlay 开启后视频加载成功时会自动播放，loop 开启时会循环播放，abortAudio 用于指定是否要禁止声音（默认禁止），placeHolder 则是作为视频尚未加载成功时的一个占位图，可选。特别注意，placeHolder 的尺寸必须和视频完全一致！！！\n2.2 代码创建&emsp;&emsp;视频纹理也可以手动在代码中创建。注意这是个异步方法，在有placeHolder时会在图片加载完毕时返回，否则将在视频准备好时返回。\nconst vt = await createVideoTexture(&#123;src, autoPlay, loop, placeHolder&#125;);\n&emsp;&emsp;对视频加以控制。注意，如果是自己创建的视频资源，请务必自己调用release方法释放！！\n// 开始播放，异步方法await vt.play();// 从`pos`秒开始播放，异步方法await vt.seek(pos);// 停止播放vt.stop();// 释放视频vt.release();// 在播放结束并且非loop的情况下，会执行vt.onEnd = () =&gt; &#123;&#125;;// 在基础库`v2.33.0`及以上，提供了暂停/唤醒方法// 同时可以配合新暴露的播放状态使用const xrSystem = wx.getXrFrameSystem();if (vt.state === xrSystem.EVideoState.Playing) &#123;  vt.pause();&#125; else if (vt.state === xrSystem.EVideoState.Paused) &#123;  vt.resume();&#125;\n&emsp;&emsp;添加到资源系统中。\nconst vt = await createVideoTexture(&#123;src, autoPlay, loop, placeHolder&#125;);// 当然，也可以添加到资源系统中scene.assets.addAsset(&#x27;video-texture&#x27;, &#x27;vt&#x27;, vt);\n2.3 在 mesh 上挂载视频&lt;xr-mesh  node-id=&quot;mesh-cube&quot; scale=&quot;1.6 0.9 0.9&quot;  geometry=&quot;cube&quot; material=&quot;standard-mat&quot;  uniforms=&quot;u_baseColorMap:video-cat&quot;  cube-shape=&quot;autoFit:true&quot;  bind:touch-shape=&quot;handleTouchCube&quot;/&gt;\n&emsp;&emsp;其中 uniforms 里绑定了相应的 asset-id。\n2.4 在 env 上挂载视频&lt;xr-env sky-map=&quot;video-skybox&quot; /&gt;&lt;xr-camera  id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;0 0 3&quot; clear-color=&quot;0.925 0.925 0.925 1&quot;  target=&quot;target&quot; background=&quot;skybox&quot; camera-orbit-control=&quot;&quot;&gt;&lt;/xr-camera&gt;\n&emsp;&emsp;其中 env、camera 都绑定了相应的 asset-id，作为天空盒呈现。\n","categories":["微信小程序","xr-frame"],"tags":["微信小程序","xr-frame"]},{"title":"XR-FRAME - 基础能力 - VisibleLayer 显示和图层","url":"/2023/12/15/XR-FRAME-%E5%9F%BA%E7%A1%80%E8%83%BD%E5%8A%9B-VisibleLayer%E6%98%BE%E7%A4%BA%E5%92%8C%E5%9B%BE%E5%B1%82/","content":"1 项目地址官方项目地址：https://github.com/dtysky/xr-frame-demo/tree/master/miniprogram/components/xr-basic-visible-layer\n2 代码解析主要代码：&lt;xr-scene id=&quot;xr-scene&quot; bind:ready=&quot;handleReady&quot;&gt;  &lt;xr-assets bind:progress=&quot;handleAssetsProgress&quot; bind:loaded=&quot;handleAssetsLoaded&quot;&gt;    &lt;xr-asset-material asset-id=&quot;standard-mat&quot; effect=&quot;standard&quot; /&gt;  &lt;/xr-assets&gt;  &lt;xr-node node-id=&quot;camera-target&quot; position=&quot;0 1.25 -5&quot;&gt;&lt;/xr-node&gt;  &lt;xr-node visible=&quot;&#123;&#123;visibleIndex === 1&#125;&#125;&quot;&gt;    &lt;xr-mesh node-id=&quot;mesh-plane&quot; position=&quot;0 -0.05 -4&quot; rotation=&quot;0 0 0&quot; scale=&quot;5 1 5&quot; geometry=&quot;plane&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.48 0.78 0.64 1&quot;&gt;&lt;/xr-mesh&gt;  &lt;/xr-node&gt;  &lt;xr-node visible=&quot;&#123;&#123;visibleIndex === 2&#125;&#125;&quot;&gt;    &lt;xr-mesh id=&quot;cube&quot; node-id=&quot;mesh-cube&quot; position=&quot;-1 0.5 -3.5&quot; scale=&quot;1 1 1&quot; rotation=&quot;0 45 0&quot; geometry=&quot;cube&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.298 0.764 0.85 1&quot;&gt;&lt;/xr-mesh&gt;  &lt;/xr-node&gt;  &lt;xr-node layer=&quot;1&quot;&gt;    &lt;xr-mesh node-id=&quot;mesh-sphere&quot; position=&quot;0 1.25 -5&quot; scale=&quot;1.25 1.25 1.25&quot; geometry=&quot;sphere&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.937 0.176 0.368 1&quot;&gt;&lt;/xr-mesh&gt;    &lt;xr-node layer=&quot;2&quot;&gt;      &lt;xr-mesh node-id=&quot;mesh-cylinder&quot; position=&quot;1 0.7 -3.5&quot; scale=&quot;1 0.7 1&quot; geometry=&quot;cylinder&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:1 0.776 0.364 1&quot;&gt;&lt;/xr-mesh&gt;    &lt;/xr-node&gt;  &lt;/xr-node&gt;  &lt;xr-camera    id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;0 1.6 0&quot; clear-color=&quot;0.925 0.925 0.925 1&quot;    target=&quot;camera-target&quot; cull-mask=&quot;&#123;&#123;cullMask&#125;&#125;&quot;    camera-orbit-control=&quot;&quot;  &gt;&lt;/xr-camera&gt;  &lt;xr-node node-id=&quot;lights&quot;&gt;    &lt;xr-light type=&quot;ambient&quot; color=&quot;1 1 1&quot; intensity=&quot;1&quot; /&gt;    &lt;xr-light type=&quot;directional&quot; rotation=&quot;40 170 0&quot; color=&quot;1 1 1&quot; intensity=&quot;3&quot; /&gt;  &lt;/xr-node&gt;&lt;/xr-scene&gt;\n2.1 visible&emsp;&emsp;当需要一个开关直截了当得让某个节点之下的所有模型或者灯光都显示或者不显示，最方便的方法就是使用 visible，当父节点设置为 false 时，即便子节点显式定义了 true，也会被隐藏。适用于 node、mesh、Light 组件。&lt;xr-node visible=&quot;&#123;&#123;visibleIndex === 1&#125;&#125;&quot;&gt;  &lt;xr-mesh node-id=&quot;mesh-plane&quot; position=&quot;0 -0.05 -4&quot; rotation=&quot;0 0 0&quot; scale=&quot;5 1 5&quot; geometry=&quot;plane&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.48 0.78 0.64 1&quot;&gt;&lt;/xr-mesh&gt;&lt;/xr-node&gt;&lt;xr-node visible=&quot;&#123;&#123;visibleIndex === 2&#125;&#125;&quot;&gt;  &lt;xr-mesh id=&quot;cube&quot; node-id=&quot;mesh-cube&quot; position=&quot;-1 0.5 -3.5&quot; scale=&quot;1 1 1&quot; rotation=&quot;0 45 0&quot; geometry=&quot;cube&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.298 0.764 0.85 1&quot;&gt;&lt;/xr-mesh&gt;&lt;/xr-node&gt;\n2.2 layer&emsp;&emsp;除了这种场景，在另外一些场景还会有更复杂的需求，比如只是想针对性得剔除掉某一类模型或是灯光，而非按照层级结构，这时候图层 layer 就派上用场了。&emsp;&emsp;对于两个 xr-node 节点，给第一层指定了 layer=1，第二层指定了 layer=2，然后将 xr-camere 节点的 cull-mask 属性（对应于 Camera 组件的 cullMask 数据）设置为 0b011。如此设置的效果应该是第一个 mesh 被渲染，第二个不被渲染。&emsp;&emsp;其中 layer 可以设置 1~32 共 32 个值，而相机的 cullMask 是一个 32 位无符号整数，每一位都代表一个 layer。只有当一个节点从顶层到自身路径中的所有节点都通过了这个 mask 的测试（从父节点到自身节点，这个路径上所有节点的 layer，所对应的 cullMusk 都为 1 时），自身才会被显示出来。这也适用于 mesh、Light 组件。\n&lt;xr-node layer=&quot;1&quot;&gt;  &lt;xr-mesh node-id=&quot;mesh-sphere&quot; position=&quot;0 1.25 -5&quot; scale=&quot;1.25 1.25 1.25&quot; geometry=&quot;sphere&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:0.937 0.176 0.368 1&quot;&gt;&lt;/xr-mesh&gt;  &lt;xr-node layer=&quot;2&quot;&gt;    &lt;xr-mesh node-id=&quot;mesh-cylinder&quot; position=&quot;1 0.7 -3.5&quot; scale=&quot;1 0.7 1&quot; geometry=&quot;cylinder&quot; material=&quot;standard-mat&quot; uniforms=&quot;u_baseColorFactor:1 0.776 0.364 1&quot;&gt;&lt;/xr-mesh&gt;  &lt;/xr-node&gt;&lt;/xr-node&gt;&lt;xr-camera  id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;0 1.6 0&quot; clear-color=&quot;0.925 0.925 0.925 1&quot;  target=&quot;camera-target&quot; cull-mask=&quot;&#123;&#123;cullMask&#125;&#125;&quot;  camera-orbit-control=&quot;&quot;&gt;&lt;/xr-camera&gt;\n","categories":["微信小程序","xr-frame"],"tags":["微信小程序","xr-frame"]},{"title":"XR-FRAME 案例 2DMarker+视频，让照片动起来","url":"/2023/12/07/XR-FRAME%E6%A1%88%E4%BE%8B2DMarker-%E8%A7%86%E9%A2%91%EF%BC%8C%E8%AE%A9%E7%85%A7%E7%89%87%E5%8A%A8%E8%B5%B7%E6%9D%A5/","content":"1 官网与项目地址&emsp;&emsp;xr-frame 官网：https://developers.weixin.qq.com/miniprogram/dev/framework/xr-frame/\n&emsp;&emsp;官方项目地址：https://github.com/dtysky/xr-frame-demo/tree/master/miniprogram/components/xr-classic-video\n2 创建小程序2.1 新建一个小程序项目\n2.2 修改 app.json新增如下代码，如已有，请忽略该步骤\n&quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;\n2.3 修改目录文件\n2.4 修改文件内容xr.json中&#123;  &quot;component&quot;: true,  &quot;renderer&quot;: &quot;xr-frame&quot;,  &quot;usingComponents&quot;: &#123;&#125;&#125;\nxr.wxml中&lt;xr-scene&gt;  &lt;xr-camera clear-color=&quot;0.4 0.8 0.6 1&quot; /&gt;&lt;/xr-scene&gt;\nindex.json中&#123;  &quot;usingComponents&quot;: &#123;    &quot;xr&quot;: &quot;../../components/xr/xr&quot;  &#125;,  &quot;disableScroll&quot;: true&#125;\nindex.js中Page(&#123;  data: &#123;    width: 300,    height: 300,    renderWidth: 300,    renderHeight: 300,  &#125;,  onLoad() &#123;    const info = wx.getSystemInfoSync();    const width = info.windowWidth;    const height = info.windowHeight;    const dpi = info.pixelRatio;    this.setData(&#123;      width, height,      renderWidth: width * dpi,      renderHeight: height * dpi    &#125;);  &#125;,&#125;)\nindex.wxml中&lt;view&gt;  &lt;xr-start    disable-scroll    id=&quot;main-frame&quot;    width=&quot;&#123;&#123;renderWidth&#125;&#125;&quot;    height=&quot;&#123;&#123;renderHeight&#125;&#125;&quot;    style=&quot;width:&#123;&#123;width&#125;&#125;px;height:&#123;&#123;height&#125;&#125;px;&quot;  /&gt;&lt;/view&gt;\n3 主要代码3.1 xr.wxml代码&lt;!-- ar-system, xr-ar-tracker切换为了Marker模式，xr-camera设置成了is-ar-camera --&gt;&lt;xr-scene ar-system=&quot;modes:Marker&quot; bind:ready=&quot;handleReady&quot;&gt;  &lt;xr-assets bind:loaded=&quot;handleAssetsLoaded&quot;&gt;    &lt;!-- 加载视频 --&gt;   &lt;xr-asset-load      type=&quot;video-texture&quot; asset-id=&quot;hikari&quot;      src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/xr-frame-team/2dmarker/hikari-v.mp4&quot; options=&quot;loop:true&quot;    /&gt;    &lt;xr-asset-material asset-id=&quot;mat&quot; effect=&quot;simple&quot; uniforms=&quot;u_baseColorMap: video-hikari&quot; /&gt;  &lt;/xr-assets&gt;  &lt;!-- 视频加载完成。再显示内容，对应于handleAssetsLoaded函数 --&gt;  &lt;xr-node wx:if=&quot;&#123;&#123;loaded&#125;&#125;&quot;&gt;    &lt;!-- ar-tracker-switch事件：监测对图片的追踪状态，仅仅在追踪到/追踪中切换，识别到了为true，否则为false --&gt;    &lt;xr-ar-tracker mode=&quot;Marker&quot; src=&quot;https://mmbizwxaminiprogram-1258344707.cos.ap-guangzhou.myqcloud.com/xr-frame/demo/xr-frame-team/2dmarker/hikari.jpg&quot; bind:ar-tracker-switch=&quot;handleTrackerSwitch&quot;&gt;      &lt;xr-mesh node-id=&quot;mesh-plane&quot; geometry=&quot;plane&quot; material=&quot;mat&quot; /&gt;    &lt;/xr-ar-tracker&gt;    &lt;xr-camera      id=&quot;camera&quot; node-id=&quot;camera&quot; position=&quot;1 1 1&quot; clear-color=&quot;0.925 0.925 0.925 1&quot;      background=&quot;ar&quot; is-ar-camera    /&gt;  &lt;/xr-node&gt;&lt;/xr-scene&gt;\n3.2 xr.js代码// components/xr/xr.jsComponent(&#123;  data: &#123;    loaded: false  &#125;,  methods: &#123;    handleReady: function(&#123;detail&#125;) &#123;      this.scene = detail.value;    &#125;,    handleAssetsLoaded: function (&#123;detail&#125;) &#123;      this.setData(&#123;loaded: true&#125;);    &#125;,    handleTrackerSwitch: function (&#123;detail&#125;) &#123;      // active为Boolean, true为识别到，false为未识别到      const active = detail.value;      const video = this.scene.assets.getAsset(&#x27;video-texture&#x27;, &#x27;hikari&#x27;);      // 通过active来控制视频的播放      active ? video.play() : video.stop();    &#125;  &#125;&#125;)","categories":["微信小程序","xr-frame"],"tags":["微信小程序","xr-frame"]},{"title":"Axios 封装","url":"/2023/12/10/axios%E5%B0%81%E8%A3%85/","content":"1 安装 Axios官网：https://www.axios-http.cn/npm i axios\n2 新建 request 模块在 utils 文件夹下新建 request.js 文件\n3 创建实例 &amp; 配置，导出实例/* 封装axios用于发送请求 */import axios from &#x27;axios&#x27;// 创建一个新的axios实例const request = axios.create(&#123;  baseURL: &#x27;http://......&#x27;,  timeout: 5000&#125;)// 添加请求拦截器request.interceptors.request.use(  function (config) &#123;    // 在发送请求之前做些什么    return config  &#125;,  function (error) &#123;    // 对请求错误做些什么    return Promise.reject(error)  &#125;)// 添加响应拦截器request.interceptors.response.use(  function (response) &#123;    // 对响应数据做点什么    return response.data  &#125;,  function (error) &#123;    // 对响应错误做点什么    return Promise.reject(error)  &#125;)export default request\n4 测试使用4.1 组件中调用&lt;script&gt;import request from &#x27;@/utils/request.js&#x27;export default &#123;  name: &#x27;LoginPage&#x27;，  created() &#123;    this.test()  &#125;,  methods: &#123;    async test() &#123;      const res = await request.get(&#x27;/login/test&#x27;)      console.log(res)    &#125;  &#125;&#125;&lt;/script&gt;\n4.2 新建 api 模块新建 /api/test.js 文件import request from &#x27;@/utils/request.js&#x27;// 按需导出export const getTest = () =&gt; &#123;  return request.get(&#x27;/login/test&#x27;)&#125;\n4.3 修改组件内容&lt;script&gt;import &#123; getTest &#125; from &#x27;@/api/test.js&#x27;export default &#123;  name: &#x27;LoginPage&#x27;，  created() &#123;    this.test()  &#125;,  methods: &#123;    async test() &#123;      const res = await getTest()      console.log(res)    &#125;  &#125;&#125;&lt;/script&gt;","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Axios"]},{"title":"ElementPlus 主题定制","url":"/2024/01/02/elementPlus%E4%B8%BB%E9%A2%98%E5%AE%9A%E5%88%B6/","content":"1 安装 scssnpm i sass -D\n2 准备定制样式文件新建 /src/styles/element/index.scss// styles/element/index.scss/* 只需要重写你需要的即可 */@forward &#x27;element-plus/theme-chalk/src/common/var.scss&#x27; with (  $colors: (    &#x27;primary&#x27;: (      &#x27;base&#x27;: green,    ),  ),);\n3 对 ElementPlus 样式进行覆盖通知 Element 采用 scss 语言，之后导入定制 scss 文件覆盖// vite.config.jsimport &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Components from &#x27;unplugin-vue-components/vite&#x27;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),    AutoImport(&#123;      resolvers: [ElementPlusResolver(&#123; importStyle: &#x27;sass&#x27; &#125;)]    &#125;),    Components(&#123;      resolvers: [ElementPlusResolver(&#123; importStyle: &#x27;sass&#x27; &#125;)]    &#125;)  ],  resolve: &#123;    alias: &#123;      &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url))    &#125;  &#125;,  css: &#123;    preprocessorOptions: &#123;      scss: &#123;        // 自动导入定制化样式文件进行样式覆盖        additionalData: `          @use &quot;@/styles/element/index.scss&quot; as *;        `      &#125;    &#125;  &#125;&#125;)\n","categories":["Vue3","ElementPlus 组件库"],"tags":["Vue3","ElementPlus 组件库"]},{"title":"ElementPlus 组件 - Carousel 轮播图","url":"/2024/01/04/elementPlus%E7%BB%84%E4%BB%B6-Carousel%E8%BD%AE%E6%92%AD%E5%9B%BE/","content":"1 官网https://element-plus.org/zh-CN/component/carousel.html\n2 基本使用方法结合使用 el-carousel 和 el-carousel-item 标签就得到了一个轮播图。默认情况下，在鼠标 hover 底部的指示器时就会触发切换。通过设置 trigger 属性为 click，可以达到点击触发的效果。\n&lt;template&gt;  &lt;div class=&quot;block text-center&quot;&gt;    &lt;span class=&quot;demonstration&quot;      &gt;Switch when indicator is hovered (default)&lt;/span    &gt;    &lt;el-carousel height=&quot;150px&quot;&gt;      &lt;el-carousel-item v-for=&quot;item in 4&quot; :key=&quot;item&quot;&gt;        &lt;h3 class=&quot;small justify-center&quot; text=&quot;2xl&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/h3&gt;      &lt;/el-carousel-item&gt;    &lt;/el-carousel&gt;  &lt;/div&gt;  &lt;div class=&quot;block text-center&quot; m=&quot;t-4&quot;&gt;    &lt;span class=&quot;demonstration&quot;&gt;Switch when indicator is clicked&lt;/span&gt;    &lt;el-carousel trigger=&quot;click&quot; height=&quot;150px&quot;&gt;      &lt;el-carousel-item v-for=&quot;item in 4&quot; :key=&quot;item&quot;&gt;        &lt;h3 class=&quot;small justify-center&quot; text=&quot;2xl&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/h3&gt;      &lt;/el-carousel-item&gt;    &lt;/el-carousel&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.demonstration &#123;  color: var(--el-text-color-secondary);&#125;.el-carousel__item h3 &#123;  color: #475669;  opacity: 0.75;  line-height: 150px;  margin: 0;  text-align: center;&#125;.el-carousel__item:nth-child(2n) &#123;  background-color: #99a9bf;&#125;.el-carousel__item:nth-child(2n + 1) &#123;  background-color: #d3dce6;&#125;&lt;/style&gt;","categories":["Vue3","ElementPlus 组件库"],"tags":["Vue3","ElementPlus 组件库"]},{"title":"ElementPlus 自动按需导入配置","url":"/2024/01/02/elementPlus%E8%87%AA%E5%8A%A8%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5%E9%85%8D%E7%BD%AE/","content":"1 安装1.1 ElementPlus 组件库地址https://element-plus.org/zh-CN/\n1.2 通过 npm 安装npm install element-plus --save\n2 按需引入组件首先需要安装 unplugin-vue-components 和 unplugin-auto-import 这两款插件npm install -D unplugin-vue-components unplugin-auto-import\n配置 vite.config.js// vite.config.jsimport &#123; defineConfig &#125; from &#x27;vite&#x27;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Components from &#x27;unplugin-vue-components/vite&#x27;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;export default defineConfig(&#123;  // ...  plugins: [    // ...    AutoImport(&#123;      resolvers: [ElementPlusResolver()],    &#125;),    Components(&#123;      resolvers: [ElementPlusResolver()],    &#125;),  ],&#125;)\n","categories":["Vue3","ElementPlus 组件库"],"tags":["Vue3","ElementPlus 组件库"]},{"title":"Mixins 混入处理","url":"/2023/12/18/mixins%E6%B7%B7%E5%85%A5%E5%A4%84%E7%90%86/","content":"1 新建文件新建 /src/mixins/test.js\n2 编写所需要混入的内容export default &#123;  // 此处编写的就是Vue组件实例的配置项，通过一定语法，可以直接混入到组件内部  // data mothods computed 生命周期函数...  // 1.注意点：如果此处和组件内，提供了同名的data或methods，则组件内优先级更高  // 2.如果编写了生命周期函数，则mixins中的生命周期函数和页面的生命周期函数，会用数组管理，统一执行  data() &#123;    return &#123;      title: &#x27;标题&#x27;    &#125;  &#125;,  methods: &#123;    sayHi() &#123;      console.log(&#x27;你好&#x27;)    &#125;  &#125;&#125;\n3 组件中导入&lt;script&gt;  import test from &#x27;@/mixins/test.js&#x27;  export default &#123;    mixins: [test],    // 调用导入的数据    created() &#123;      console.log(this.title),      this.sayHi()    &#125;  &#125;&lt;/script&gt;\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Mixins"]},{"title":"props中默认为对象时的写法","url":"/2023/12/13/props%E4%B8%AD%E9%BB%98%E8%AE%A4%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E5%86%99%E6%B3%95/","content":"&lt;script&gt;export default &#123;  name: &#x27;GoodsItem&#x27;,  props: &#123;    item: &#123;      type: Object,      // 写成函数      default: () =&gt; &#123;        return &#123;&#125;      &#125;    &#125;  &#125;&#125;&lt;/script&gt;\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2"]},{"title":"Storage 存储模块 - Vuex 持久化处理","url":"/2023/12/12/storage%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9D%97-vuex%E6%8C%81%E4%B9%85%E5%8C%96%E5%A4%84%E7%90%86/","content":"1 新建 storage 模块前提：Vuex 构建子模块新建 /utils/storage.js\nconst INFO_KEY = &#x27;hm_shopping_info&#x27;// 获取个人信息export const getInfo = () =&gt; &#123;  const result = localStorage.getItem(INFO_KEY)  return result    ? JSON.parse(result)    : &#123;        token: &#x27;&#x27;,        userId: &#x27;&#x27;      &#125;&#125;// 设置个人信息export const setInfo = info =&gt; &#123;  localStorage.setItem(INFO_KEY, JSON.stringify(info))&#125;// 移除个人信息export const removeInfo = () =&gt; &#123;  localStorage.removeItem(INFO_KEY)&#125;\n2 Vuex User 模块持久化处理import &#123; getInfo, setInfo &#125; from &#x27;@/utils/storage&#x27;export default &#123;  namespaced: true,  state() &#123;    return &#123;      userInfo: getInfo()    &#125;  &#125;,  mutations: &#123;    setUserInfo(state, obj) &#123;      state.userInfo = obj      setInfo(obj)    &#125;  &#125;,  actions: &#123;&#125;&#125;","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Vuex"]},{"title":"Toast 轻提示","url":"/2023/12/10/toast%E8%BD%BB%E6%8F%90%E7%A4%BA/","content":"1 注册安装官网：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/toast\nimport &#123; Toast &#125; from &#x27;vant&#x27;Vue.use(Toast)\n2 两种使用方式2.1 导入调用组件内 或 非组件中 均可import &#123; Toast &#125; from &#x27;vant&#x27;Toast(&#x27;提示内容&#x27;)Toast.success(&#x27;成功文案&#x27;)\n2.2 通过 this 直接调用必须组件内本质：全局引入 Toast 组件后，会自动将方法注册挂载到了 Vue 原型上 Vue.prototype.$toast = xxx\nthis.$toast(&#x27;提示内容&#x27;)this.$toast.success(&#x27;成功文案&#x27;)","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库","Toast"]},{"title":"Vant 组件 - ActionSheet 动作面板","url":"/2023/12/14/vant%E7%BB%84%E4%BB%B6-ActionSheet%E5%8A%A8%E4%BD%9C%E9%9D%A2%E6%9D%BF/","content":"1 注册安装官网：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/action-sheet\nimport Vue from &#x27;vue&#x27;import &#123; ActionSheet &#125; from &#x27;vant&#x27;Vue.use(ActionSheet)\n2 使用方式动作面板通过 actions 属性来定义选项，actions 属性是一个由对象构成的数组，数组中的每个对象配置一列，对象格式见文档下方表格。\n&lt;van-cell is-link title=&quot;基础用法&quot; @click=&quot;show = true&quot; /&gt;&lt;van-action-sheet v-model=&quot;show&quot; :actions=&quot;actions&quot; @select=&quot;onSelect&quot; /&gt;\nimport &#123; Toast &#125; from &#x27;vant&#x27;;export default &#123;  data() &#123;    return &#123;      show: false,      actions: [&#123; name: &#x27;选项一&#x27; &#125;, &#123; name: &#x27;选项二&#x27; &#125;, &#123; name: &#x27;选项三&#x27; &#125;],    &#125;;  &#125;,  methods: &#123;    onSelect(item) &#123;      // 默认情况下点击选项时不会自动收起      // 可以通过 close-on-click-action 属性开启自动收起      this.show = false;      Toast(item.name);    &#125;,  &#125;,&#125;;","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库"]},{"title":"Vant 组件 - Checkbox 复选框","url":"/2023/12/15/vant%E7%BB%84%E4%BB%B6-Checkbox%E5%A4%8D%E9%80%89%E6%A1%86/","content":"1 注册安装官网：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/checkbox\nimport Vue from &#x27;vue&#x27;;import &#123; Checkbox, CheckboxGroup &#125; from &#x27;vant&#x27;;Vue.use(Checkbox);Vue.use(CheckboxGroup);\n2 使用方式通过 v-model 绑定复选框的勾选状态。&lt;van-checkbox v-model=&quot;checked&quot;&gt;复选框&lt;/van-checkbox&gt;export default &#123;  data() &#123;    return &#123;      checked: true,    &#125;;  &#125;,&#125;;\n","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库"]},{"title":"Vant组件 - Dialog 弹出框","url":"/2023/12/15/vant%E7%BB%84%E4%BB%B6-Dialog%E5%BC%B9%E5%87%BA%E6%A1%86/","content":"1 注册安装官网：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/dialog\nimport Vue from &#x27;vue&#x27;;import &#123; Dialog &#125; from &#x27;vant&#x27;;// 全局注册Vue.use(Dialog);\n2 使用方式用于确认消息，包含取消和确认按钮。\nDialog.confirm(&#123;  title: &#x27;标题&#x27;,  message: &#x27;弹窗内容&#x27;,&#125;)  .then(() =&gt; &#123;    // on confirm  &#125;)  .catch(() =&gt; &#123;    // on cancel  &#125;);\n当然，引入 Dialog 组件后，会自动在 Vue 的 prototype 上挂载 $dialog 方法，在所有组件内部都可以直接调用此方法。\nexport default &#123;  mounted() &#123;    this.$dialog.alert(&#123;      message: &#x27;弹窗内容&#x27;,    &#125;);  &#125;,&#125;;\n","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库"]},{"title":"Vant 组件 - Grid 宫格","url":"/2023/12/13/vant%E7%BB%84%E4%BB%B6-Grid%E5%AE%AB%E6%A0%BC/","content":"1 注册安装官网：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/grid\nimport Vue from &#x27;vue&#x27;import &#123; Grid, GridItem &#125; from &#x27;vant&#x27;Vue.use(Grid)Vue.use(GridItem)\n2 使用方式通过 icon 属性设置格子内的图标，text 属性设置文字内容。&lt;van-grid&gt;  &lt;van-grid-item icon=&quot;photo-o&quot; text=&quot;文字&quot; /&gt;  &lt;van-grid-item icon=&quot;photo-o&quot; text=&quot;文字&quot; /&gt;  &lt;van-grid-item icon=&quot;photo-o&quot; text=&quot;文字&quot; /&gt;  &lt;van-grid-item icon=&quot;photo-o&quot; text=&quot;文字&quot; /&gt;&lt;/van-grid&gt;\n","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库"]},{"title":"Vant 组件 - Search 搜索框","url":"/2023/12/13/vant%E7%BB%84%E4%BB%B6-Search%E6%90%9C%E7%B4%A2%E6%A1%86/","content":"1 注册安装官网：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/search\nimport Vue from &#x27;vue&#x27;import &#123; Search &#125; from &#x27;vant&#x27;Vue.use(Search)\n2 使用方式v-model 用于控制搜索框中的文字，background 可以自定义搜索框外部背景色。&lt;van-search v-model=&quot;value&quot; placeholder=&quot;请输入搜索关键词&quot; /&gt;export default &#123;  data() &#123;    return &#123;      value: &#x27;&#x27;,    &#125;;  &#125;,&#125;;\n","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库"]},{"title":"Vant 组件 - Swipe 轮播","url":"/2023/12/13/vant%E7%BB%84%E4%BB%B6-Swipe%E8%BD%AE%E6%92%AD/","content":"1 注册安装官网：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/swipe\nimport Vue from &#x27;vue&#x27;import &#123; Swipe, SwipeItem &#125; from &#x27;vant&#x27;Vue.use(Swipe)Vue.use(SwipeItem)\n2 使用方式每个 SwipeItem 代表一张轮播卡片，可以通过 autoplay 属性设置自动轮播的间隔。&lt;van-swipe class=&quot;my-swipe&quot; :autoplay=&quot;3000&quot; indicator-color=&quot;white&quot;&gt;  &lt;van-swipe-item&gt;1&lt;/van-swipe-item&gt;  &lt;van-swipe-item&gt;2&lt;/van-swipe-item&gt;  &lt;van-swipe-item&gt;3&lt;/van-swipe-item&gt;  &lt;van-swipe-item&gt;4&lt;/van-swipe-item&gt;&lt;/van-swipe&gt;&lt;style&gt;  .my-swipe .van-swipe-item &#123;    color: #fff;    font-size: 20px;    line-height: 150px;    text-align: center;    background-color: #39a9ed;  &#125;&lt;/style&gt;\n","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库"]},{"title":"vant组件-Tab标签页","url":"/2023/12/18/vant%E7%BB%84%E4%BB%B6-Tab%E6%A0%87%E7%AD%BE%E9%A1%B5/","content":"1 注册安装官网：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/tab\nimport Vue from &#x27;vue&#x27;import &#123; Tab, Tabs &#125; from &#x27;vant&#x27;Vue.use(Tab)Vue.use(Tabs)\n2 使用方式通过 v-model 绑定当前激活标签对应的索引值，默认情况下启用第一个标签。\n&lt;van-tabs v-model=&quot;active&quot;&gt;  &lt;van-tab title=&quot;标签 1&quot;&gt;内容 1&lt;/van-tab&gt;  &lt;van-tab title=&quot;标签 2&quot;&gt;内容 2&lt;/van-tab&gt;  &lt;van-tab title=&quot;标签 3&quot;&gt;内容 3&lt;/van-tab&gt;  &lt;van-tab title=&quot;标签 4&quot;&gt;内容 4&lt;/van-tab&gt;&lt;/van-tabs&gt;export default &#123;  data() &#123;    return &#123;      active: 2,    &#125;;  &#125;,&#125;","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库"]},{"title":"Vant 组件定制主题的方法","url":"/2023/12/12/vant%E7%BB%84%E4%BB%B6%E5%AE%9A%E5%88%B6%E4%B8%BB%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95/","content":"1 官网地址官网：https://vant-contrib.gitee.io/vant/v2/#/zh-CN/theme\n2 引入样式源文件2.1 按需引入// 在 babel.config.js 中配置按需引入样式源文件，注意 babel6 不支持按需引入样式，请手动引入样式。// 注：检查是否安装babel-plugin-import// 安装插件// npm i babel-plugin-import -Dmodule.exports = &#123;  plugins: [    [      &#x27;import&#x27;,      &#123;        libraryName: &#x27;vant&#x27;,        libraryDirectory: &#x27;es&#x27;,        // 指定样式路径        style: (name) =&gt; `$&#123;name&#125;/style/less`,      &#125;,      &#x27;vant&#x27;,    ],  ],&#125;;\n2.2 手动引入// main.js// 引入全部样式import &#x27;vant/lib/index.less&#x27;;// 引入单个组件样式import &#x27;vant/lib/button/style/less&#x27;;\n3 修改样式变量3.1 新建主题样式文件新建 /src/styles/theme.less，修改自己需要的样式@border-color: @gray-3;@border-width-base: 1px;@border-radius-sm: 2px;@border-radius-md: 4px;@border-radius-lg: 8px;@border-radius-max: 999px;\n3.2 在 vue.config.js 中引入// vue.config.jsconst path = require(&#x27;path&#x27;)const Path =  path.join(__dirname, &#x27;./src/styles/theme.less&#x27;)module.exports = &#123;  css: &#123;    loaderOptions: &#123;      less: &#123;        // 若 less-loader 版本小于 6.0，请移除 lessOptions 这一级，直接配置选项。        lessOptions: &#123;          modifyVars: &#123;            // 直接覆盖变量            &#x27;text-color&#x27;: &#x27;#111&#x27;,            &#x27;border-color&#x27;: &#x27;#eee&#x27;,            // 或者可以通过 less 文件覆盖（文件路径为绝对路径）            hack: `true; @import &quot;$&#123;Path&#125;&quot;;`,          &#125;,        &#125;,      &#125;,    &#125;,  &#125;,&#125;;","categories":["Vue2","Vant 组件库"],"tags":["Vue2","Vant 组件库"]},{"title":"Vue2 项目的打包发布","url":"/2023/12/21/vue2%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/","content":"1 命令执行该命令，在项目根目录会自动创建一个文件夹 dist，dist中的文件就是打包后的文件，只需要放在服务器中即可。npm run build\n2 配置默认情况下，需要放到服务器根目录打开，如果希望双击运行，需要配置 publicPath 配成相对路径。\n// vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123;  publicPath: &#x27;./&#x27;,  transpileDependencies: true&#125;)\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2"]},{"title":"Vuex 中主模块调用子模块的数据","url":"/2023/12/12/vuex%E4%B8%AD%E4%B8%BB%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B0%E6%8D%AE/","content":"1 构建子模块参考方法：Vuex 构建子模块\n2 调用子模块数据// /store/index.jsimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import user from &#x27;@/store/modules/user.js&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;&#125;,  getters: &#123;    token(state) &#123;      return state.user.userInfo.token    &#125;  &#125;,  mutations: &#123;&#125;,  actions: &#123;&#125;,  modules: &#123;    user  &#125;&#125;)\n3 在 router/index.js 中调用import store from &#x27;@/store&#x27;.....const authUrl = [&#x27;/pay&#x27;, &#x27;/myorder&#x27;]router.beforeEach((to, from, next) =&gt; &#123;  const token = store.getters.token  if (!authUrl.includes(to.path)) &#123;    next()    return  &#125;  if (token) &#123;    next()  &#125; else &#123;    next(&#x27;/login&#x27;)  &#125;&#125;)\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Vuex"]},{"title":"Vuex 中子模块调用全局数据","url":"/2023/12/21/vuex%E4%B8%AD%E5%AD%90%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE/","content":"1 构建子模块参考方法：Vuex 构建子模块\n2 子模块调用全局数据Vuex3 官方文档：https://v3.vuex.vuejs.org/zh/actions: &#123;    logout(context) &#123;      context.commit(&#x27;setUserInfo&#x27;, &#123;&#125;)      // 调用另一个cart子模块的函数      context.commit(&#x27;cart/setCartList&#x27;, [], &#123; root: true &#125;)    &#125;  &#125;\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Vuex"]},{"title":"Vuex 中子模块调用自身数据","url":"/2023/12/17/vuex%E4%B8%AD%E5%AD%90%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8%E8%87%AA%E8%BA%AB%E6%95%B0%E6%8D%AE/","content":"1 构建子模块参考方法：Vuex 构建子模块\n2 子模块调用自身数据Vuex3 官方文档：https://v3.vuex.vuejs.org/zh/import &#123; getCartList &#125; from &#x27;@/api/cart.js&#x27;export default &#123;  namespaced: true,  state() &#123;    return &#123;      cartList: []    &#125;  &#125;,  mutations: &#123;    setCartList(state, newList) &#123;      state.cartList = newList    &#125;  &#125;,  actions: &#123;    async getCartAction(context) &#123;      const &#123; data &#125; = await getCartList()      data.list.forEach((item) =&gt; &#123;        item.isChecked = true      &#125;)      context.commit(&#x27;setCartList&#x27;, data.list)    &#125;  &#125;,  getters: &#123;    // 求所有的商品累加总数    cartTotal(state) &#123;      return state.cartList.reduce((sum, item) =&gt; sum + item.goods_num, 0)    &#125;,    // 选中的商品    selCartList(state) &#123;      return state.cartList.filter((item) =&gt; item.isChecked)    &#125;,    // 选中的总数    selCount(state, getters) &#123;      return getters.selCartList.reduce((sum, item) =&gt; item.goods_num + sum, 0)    &#125;,    // 选中的总价    selPrice(state, getters) &#123;      return getters.selCartList.reduce((sum, item) =&gt; &#123;        return sum + item.goods_num * item.goods.goods_price_min      &#125;, 0)    &#125;  &#125;&#125;\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Vuex"]},{"title":"Vuex 构建子模块","url":"/2023/12/12/vuex%E6%9E%84%E5%BB%BA%E5%AD%90%E6%A8%A1%E5%9D%97/","content":"1 新建 user.js 子模块Vuex3 官方文档：https://v3.vuex.vuejs.org/zh/https://v3.vuex.vuejs.org/zh/\n新建 /store/modules/user.js 文件\nexport default &#123;  namespaced: true,  state() &#123;    return &#123;      userInfo: &#123;        token: &#x27;&#x27;,        userId: &#x27;&#x27;      &#125;    &#125;  &#125;,  mutations: &#123;&#125;,  actions: &#123;&#125;&#125;\n2 挂载到 vuex 上import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import user from &#x27;./modules/user&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123;  modules: &#123;    user  &#125;&#125;)\n3 提供 mutationsmutations: &#123;  setUserInfo (state, obj) &#123;    state.userInfo = obj  &#125;,&#125;,\n4 页面中 commit 调用// 登录按钮（校验 &amp; 提交）async login () &#123;  if (!this.validFn()) &#123;    return  &#125;  ...  const res = await codeLogin(this.mobile, this.msgCode)  this.$store.commit(&#x27;user/setUserInfo&#x27;, res.data)  this.$router.push(&#x27;/&#x27;)  this.$toast(&#x27;登录成功&#x27;)&#125;","categories":["Vue2","Vue2 基础"],"tags":["Vue2","Vuex"]},{"title":"新建 Vue2 项目的步骤","url":"/2023/12/07/%E6%96%B0%E5%BB%BAVue2%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%AD%A5%E9%AA%A4/","content":"1 安装脚手架 VueClinpm install -g @vue/cli\n2 自定义新建项目vue create 项目名称\n&emsp;&emsp;选择项：Manually select features; Babel, Router, Vuex, Linter / Foratter; 2.x; n(hash); Less; EsLint + Prettier; Lint on save; In dedicated config files; no(no save this as a preset for futuer projects).\ncd 项目名称npm run serve\n3 配置 EsLint 和 Prettier3.1 .eslintrc.js 文件module.exports = &#123;  root: true,  env: &#123;    node: true  &#125;,  extends: [    &#x27;plugin:vue/essential&#x27;,    &#x27;eslint:recommended&#x27;,    &#x27;plugin:prettier/recommended&#x27;  ],  parserOptions: &#123;    parser: &#x27;@babel/eslint-parser&#x27;  &#125;,  rules: &#123;    &#x27;prettier/prettier&#x27;: [      &#x27;warn&#x27;,      &#123;        singleQuote: true, // 单引号        semi: false, // 无分号        printWidth: 80, // 每行宽度至多80字符        trailingComma: &#x27;none&#x27;, // 不加对象|数组最后逗号        endOfLine: &#x27;auto&#x27; // 换行符号不限制（win mac 不一致）      &#125;    ],    &#x27;vue/multi-word-component-names&#x27;: [      &#x27;warn&#x27;,      &#123;        ignores: [&#x27;index&#x27;] // vue组件名称多单词组成（忽略index.vue）      &#125;    ],    // 或者，不再强制要求组件命名    // &#x27;vue/multi-word-component-names&#x27;: 0,    &#x27;vue/no-setup-props-destructure&#x27;: [&#x27;off&#x27;], // 关闭 props 解构的校验    // 💡 添加未定义变量错误提示，create-vue@3.6.3 关闭，这里加上是为了支持下一个章节演示。    &#x27;no-undef&#x27;: &#x27;error&#x27;  &#125;&#125;\n3.2 .eslintignore 文件node_modulesdist\n3.3 .prettierrc.json 文件&#123;  &quot;$schema&quot;: &quot;https://json.schemastore.org/prettierrc&quot;,  &quot;semi&quot;: false,  &quot;tabWidth&quot;: 2,  &quot;singleQuote&quot;: true,  &quot;printWidth&quot;: 100,  &quot;trailingComma&quot;: &quot;none&quot;&#125;\n3.4 .prettierignore 文件node_modulesdistsrc/assetspackage-lock.jsons\n3.5 VSCode 扩展开启情况&emsp;&emsp;开启：ESLint, Auto Close Tag, Auto Rename Tag, Error Lens, Vetur\n","categories":["Vue2","Vue2 基础"],"tags":["Vue2"]},{"title":"新建 Vue3 项目的步骤","url":"/2024/01/02/%E6%96%B0%E5%BB%BAVue3%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%AD%A5%E9%AA%A4/","content":"1 新建项目npm init vue@latest\n2 启动项目cd 项目名称npm installnpm run dev\n3 配置 Eslint 和 Prettier3.1 .eslintrc.cjs 文件/* eslint-env node */require(&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;)module.exports = &#123;  root: true,  extends: [    &#x27;plugin:vue/vue3-essential&#x27;,    &#x27;eslint:recommended&#x27;,    &#x27;@vue/eslint-config-prettier/skip-formatting&#x27;  ],  parserOptions: &#123;    ecmaVersion: &#x27;latest&#x27;  &#125;,  rules: &#123;    &#x27;prettier/prettier&#x27;: [      &#x27;warn&#x27;,      &#123;        singleQuote: true, // 单引号        semi: false, // 无分号        printWidth: 80, // 每行宽度至多80字符        trailingComma: &#x27;none&#x27;, // 不加对象|数组最后逗号        endOfLine: &#x27;auto&#x27; // 换行符号不限制（win mac 不一致）      &#125;    ],    &#x27;vue/multi-word-component-names&#x27;: [      &#x27;warn&#x27;,      &#123;        ignores: [&#x27;index&#x27;] // vue组件名称多单词组成（忽略index.vue）      &#125;    ],    // 或者，不再强制要求组件命名    // &#x27;vue/multi-word-component-names&#x27;: 0,    &#x27;vue/no-setup-props-destructure&#x27;: [&#x27;off&#x27;], // 关闭 props 解构的校验    // 💡 添加未定义变量错误提示，create-vue@3.6.3 关闭，这里加上是为了支持下一个章节演示。    &#x27;no-undef&#x27;: &#x27;error&#x27;  &#125;&#125;\n3.2 .prettierrc.json 文件&#123;  &quot;$schema&quot;: &quot;https://json.schemastore.org/prettierrc&quot;,  &quot;semi&quot;: false,  &quot;tabWidth&quot;: 2,  &quot;singleQuote&quot;: true,  &quot;printWidth&quot;: 100,  &quot;trailingComma&quot;: &quot;none&quot;&#125;","categories":["Vue3","Vue3 基础"],"tags":["Vue3"]},{"title":"完全数","url":"/2024/01/09/%E7%AE%97%E6%B3%95-%E6%98%93%E9%94%99%E9%A2%98-%E5%AE%8C%E5%85%A8%E6%95%B0/","content":"1 题目题目描述https://www.acwing.com/problem/content/727/\n一个整数，除了本身以外的其他所有约数的和如果等于该数，那么我们就称这个整数为完全数。\n例如，$ 6 $ 就是一个完全数，因为它的除了本身以外的其他约数的和为 $ 1 + 2 + 3 = 6 $。\n现在，给定你 $ N $ 个整数，请你依次判断这些数是否是完全数。\n输入格式第一行包含整数 $ N $，表示共有 $ N $ 个测试用例。\n接下来 $ N $ 行，每行包含一个需要你进行判断的整数 $ X $。\n输出格式每个测试用例输出一个结果，每个结果占一行。\n如果测试数据是完全数，则输出 X is perfect，其中 $ X $ 是测试数据。\n如果测试数据不是完全数，则输出 X is not perfect，其中 $ X $ 是测试数据。\n数据范围$ 1 \\leq N \\leq 100 $，\n$ 1 \\leq X \\leq 10^{8} $\n时/空限制1s / 64MB\n2 解答#include &lt;iostream&gt;using namespace std;int main() &#123;    int n, m;    scanf(&quot;%d&quot;, &amp;n);    while (n -- ) &#123;        scanf(&quot;%d&quot;, &amp;m);        int s = m;        for (int i = 1; i &lt; m / i; i ++ ) &#123;            if (m % i == 0) &#123;                s = s - i - m / i;            &#125;        &#125;        if (s == -m) printf(&quot;%d is perfect\\n&quot;, m);        else printf(&quot;%d is not perfect\\n&quot;, m);    &#125;    return 0;&#125;\n注意：问题在于不要超时。\n","categories":["算法","易错题"],"tags":["算法","易错题"]},{"title":"项目与 Github 连接的步骤","url":"/2023/12/06/%E9%A1%B9%E7%9B%AE%E4%B8%8Egithub%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%AD%A5%E9%AA%A4/","content":"1 进入 Github ，新建仓库1.1 点击 New repository\n1.2 填写 Repository name 和 Description ，之后点击 Create repository\n\n\n2 使用 Git 管理自己的项目2.1 初始化本地 Git 仓库git init\n2.2 在项目根目录中新建 .gitignore 忽略文件，并配置如下# 忽略 node_modules 目录/node_modules\n2.3 将所有文件都存入暂存区git add .\n2.4 本地提交更新git comit -m &quot;init project&quot;\n2.5 把项目托管到 Github 上git remote add origin git@github.com:banlixxx/test.gitgit branch -M maingit push -u origin main","categories":["Git","Git 基础"],"tags":["Git","笔记","Github"]}]